<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2020年更新计划</title>
      <link href="/2020/02/23/%E9%9A%8F%E7%AC%94/hello-world/"/>
      <url>/2020/02/23/%E9%9A%8F%E7%AC%94/hello-world/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>坚持不懈 始终如一</p></blockquote><div class="note info">            <ul><li>每周至少更新一篇文章</li><li>每个月进行一次总结</li></ul>          </div><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Micro</title>
      <link href="/2018/03/06/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001-%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/03/06/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001-%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>– </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">set sql_mode&#x3D;&quot;&quot;;</span><br><span class="line">drop table if exists a,b,c,d,e;</span><br><span class="line">create table a(a tinyint, b tinyint, c tinyint, </span><br><span class="line">key(a),key(b),key(c),key(a,b,c),</span><br><span class="line">unique key(b,c),key(c,a,b))engine&#x3D;innodb;</span><br><span class="line">create table b like a;</span><br><span class="line">create table c like a;</span><br><span class="line">create table d like a;</span><br><span class="line">create table e like a;</span><br><span class="line">drop procedure if exists p;</span><br><span class="line">delimiter $</span><br><span class="line">create procedure p()</span><br><span class="line">begin</span><br><span class="line">  declare continue handler for sqlexception begin end;</span><br><span class="line">   repeat</span><br><span class="line">    if rand()&gt;0.2 then start transaction; end if;</span><br><span class="line"></span><br><span class="line">if rand()&gt;0.1 then set @a:&#x3D;floor(rand()*10); end if;</span><br><span class="line">if rand()&gt;0.1 then set @b:&#x3D;floor(rand()*10); end if;</span><br><span class="line">if rand()&gt;0.1 then set @c:&#x3D;floor(rand()*10); end if;</span><br><span class="line"></span><br><span class="line">if rand()&gt;0.5 then replace into a(a,b,c) values(@a,@b,@c); end if;</span><br><span class="line">if rand()&gt;0.5 then replace into b(a,b,c) values(@a,@b,@c); end if;</span><br><span class="line">if rand()&gt;0.5 then replace into c(a,b,c) values(@a,@b,@c); end if;</span><br><span class="line">if rand()&gt;0.5 then replace into d(a,b,c) values(@a,@b,@c); end if;</span><br><span class="line">if rand()&gt;0.5 then replace into e(a,b,c) values(@a,@b,@c); end if;</span><br><span class="line"></span><br><span class="line">if rand()&gt;0.5 then update a set b&#x3D;@a where c&#x3D;@a; end if;</span><br><span class="line">if rand()&gt;0.5 then update b set c&#x3D;@b where a&#x3D;@b; end if;</span><br><span class="line">if rand()&gt;0.5 then update c set d&#x3D;@c where b&#x3D;@c; end if;</span><br><span class="line">if rand()&gt;0.5 then update d set e&#x3D;@d where c&#x3D;@d; end if;</span><br><span class="line">if rand()&gt;0.5 then update e set a&#x3D;@e where d&#x3D;@e; end if;</span><br><span class="line"></span><br><span class="line">if rand()&gt;0.5 then delete from a where a&#x3D;@a; end if;</span><br><span class="line">if rand()&gt;0.5 then delete from b where b&#x3D;@b; end if;</span><br><span class="line">if rand()&gt;0.5 then delete from c where c&#x3D;@c; end if;</span><br><span class="line">if rand()&gt;0.5 then delete from d where a&#x3D;@d; end if;</span><br><span class="line">if rand()&gt;0.5 then delete from e where b&#x3D;@c; end if;</span><br><span class="line"></span><br><span class="line">if rand()&gt;0.2 then commit; end if;</span><br><span class="line">   until rand()&gt;0.9 end repeat;</span><br><span class="line">end $</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">call p();</span><br></pre></td></tr></table></figure><p>this is a test.</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go Micro </tag>
            
            <tag> Go </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译和链接</title>
      <link href="/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/"/>
      <url>/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>认识自己的无知是认识世界的最可靠的方法 –《随笔集》 </p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个程序的的生命周期从编写源代码开始，在编写完源代码之后，就可以进行代码的构建了。其中第一步就是编译,编译阶段会生成各文件的目标文件，将生成的目标文件和系统库文件进行链接，最终生成了可以在特定平台运行的可执行文件。最后操作系统装载器会加载、解包这些数据，并将这些数据用于程序的执行阶段。</p><div class="note info">            <p>程序的生命周期简化</p><ul><li>编写源代码</li><li>编译</li><li>链接</li><li>装载</li><li>执行</li></ul>          </div><a id="more"></a><h1 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从广义上来讲，编译就是讲一种编程语言源代码转换为另一种编程语言描述的源代码。</p><ul><li>编译器负责编译程序。</li><li>编译器的输入时一个编译单元。通常编译单元指的是一个包含源代码的文本文件。</li><li>一个程序通常包含多个编译单元。</li><li>编译过程的输出是一系列二进制目标文件的集合，其中每一个目标文件对应一个作为输入的编译单元。</li></ul><p>我们通常会遇到以下几个相关概念：</p><ul><li>编译：从严格意义上讲，编译指的是讲高级语言编写的源代码翻译成低级语言描述代码的过程。</li><li>交叉编译：如果在一个平台(相同CPU或者操作系统)上进行的编译，生成的代码可以在其他平台上面执行，那么这种编译过程就称为交叉编译。</li><li>反编译：降低级语言编写的源代码转换成高级语言描述的源代码的过程。</li></ul><h2 id="编译的各个阶段"><a href="#编译的各个阶段" class="headerlink" title="编译的各个阶段"></a>编译的各个阶段</h2><ol><li>预处理阶段</li><li>语言分析阶段</li><li>汇编阶段</li><li>优化阶段</li><li>代码生成阶段</li></ol><h2 id="目标文件属性"><a href="#目标文件属性" class="headerlink" title="目标文件属性"></a>目标文件属性</h2><p>编译阶段的输出是一个或者多个目标文件，以下分析这些目标文件的结构。</p><ul><li>目标文件是通过其对应的源代码编译得到。</li><li>符号(symbol)和节(section)是目标文件的基本组成部分，其中符号表示的是程序中的内存地址或者数据内存。绝大多数的目标文件中包含代码节(.text)、初始化数据节(.data)、未初始化数据节(.bss)以及一些特殊节(比如试调信息等)。</li><li>构建程序的目的在于将编译的每个独立的源代码文件生成节拼接到一个二进制可执行文件中。最终生成的二进制文件中包含了多个相同类型的节(.text、.data 和 .bss节等)，而这些节是从每个独立的目标文件中拼接得到的。</li><li>目标文件中独立的节都可能包含在最终的程序内存映射中，因此目标文件中每个节的起始地址都会被临时设置成0，等待连接时调整。在程序构建过程的后续阶段(链接阶段)中会确认程序内存映射中每个独立节的实际地址范围。</li><li>在将目标文件的节拼接到程序内存映射的过程中。其中唯一重要的参数是节的长度，准确的说是节的地址范围。</li><li>目标文件中不包含专门的节会影响堆和栈中的数据。内存映射中的堆和栈内容完全在运行时确定，除了需要指定堆和栈的默认长度以外，并不需要程序指定任何其他初始化设置。</li><li>目标文件只包含了程序.bss(未初始化数据)节的基本信息， 而.bss节本身也仅仅只有字节的长度信息。装载器会利用这有限的数据为.bss节建立足够其数据存储的内存空间。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来讲，目标文件中的信息是根据一组特定的二进制格式规范集合进行存储的，其中范围定义了多种不同平台的细节信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制格式规范的设计通常是为了支持C/C++语言结构并帮助其解决实现问题。二进制格式规范常常会涵盖各种各样的文件类型，比如可执行文件、静态库和动态库等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Linux上，可执行和可链接格式(Executable and Linkable Format, ELF)已经得到了普遍运用。在Windows上，二进制文件通常遵循PE/COFF格式规范。</p><div class="note info">            <h2 id="为什么要进行编译？"><a href="#为什么要进行编译？" class="headerlink" title="为什么要进行编译？"></a>为什么要进行编译？</h2><p>答：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前很多语言实现了一阶段式构建过程, 比如：python，javaScripts。<br>为了程序构建阶段支持复用(此处指的是二进制级别的复用)，所以将程序构建分为两个阶段(编译阶段和链接阶段)。</p>          </div><h1 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h1><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接过程第一个阶段仅仅进行拼接，其过程是将分散在单独目标文件中不同类型的节拼接到程序内存映射节中。</p><p>如下图所示：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了完成该任务，需要将之前预留的空间，也就是节中从0开始的地址范围转换成最终程序的内存映射中更具体的地址范围。</p><h2 id="解析引用"><a href="#解析引用" class="headerlink" title="解析引用"></a>解析引用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将节的地址范围转换成程序内存映射地址范围，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc -c function.c main.c</span></span><br><span class="line"><span class="meta"># gcc funtion.o main.o -o demoApp</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc function.c main.c -o demoApp</span></span><br></pre></td></tr></table></figure><p>反汇编main.o文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># objdump -D -M intel main.o</span></span><br></pre></td></tr></table></figure><p>对含有未初始化数据的.bss节进行反汇编操作，发现变量nCompletionStatus</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># objdump -x -j .bss demoApp</span></span><br></pre></td></tr></table></figure><h1 id="可执行文件属性"><a href="#可执行文件属性" class="headerlink" title="可执行文件属性"></a>可执行文件属性</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接过程的最终结果是二进制可执行文件，其结构布局遵循特定目标平台的可执行文件格式。</p><p>启动代码有两种不同形式：</p><ul><li>crt0 是程序入口点，这是程序代码的第一部分，在内核控制下执行。</li><li>crt1 是启动例程(startuproutine)，可以在main函数执行前与程序终止后完成一些任务。</li></ul><p>程序可执行文件的整体结构大致如下图：</p><h2 id="各种节的类型"><a href="#各种节的类型" class="headerlink" title="各种节的类型"></a>各种节的类型</h2><p>待补充…</p><h2 id="各种符号类型"><a href="#各种符号类型" class="headerlink" title="各种符号类型"></a>各种符号类型</h2><p>待补充…</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Compile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从存储器到内存映射布局</title>
      <link href="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/"/>
      <url>/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>就算影子也会在黑暗的时候离开</p></blockquote><p>在日常工作中，经常会有同学提出这样的问题，</p><ul><li>“我的程序运行时究竟占用了多大的内存?”</li><li>“我的程序占用的虚拟内存非常大，这个正常么?”</li></ul><div class="note info">            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要从以下几个方向，深入浅出的说明内存的基本布局，后续会更新内存的管理的文章。</p><ul><li>计算机体系结构</li><li>存储器缓存策略</li><li>虚拟内存</li><li>虚拟地址</li><li>进程的内存划分方案</li></ul>          </div><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机技术领域的变化日新月异，集成电路技术带来的元件不仅种类繁多，而且在功能方面还在不断改进增强。按照摩尔定律，集成电路上可容纳的晶体管数目大约每两年便会增加一倍。而与晶体管数据量密切相关的处理能力也将提升一倍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经验告诉我们，想要应对这种快速的变化，就是在经常变动的实现层次之上，利用抽象和泛华的方法为计算机系统定义全局目标和结构体系。这种方法的核心在于描述抽象的方式，该方式要确保在去除相对无关的实现细节后，任何新的实现与核心定义都能保持一致。</p><p>整个计算机体系结构可用下图表示:</p><a id="more"></a><p>在计算机系统中，有一些和存储器相关的趣事：</p><ul><li>人们对存储器容量总是无法满足，而且存储器容量总是供不应求。</li><li>存储器技术似乎是导致处理器性能障碍的主要原因<br>– 这种被称为”处理器和存储器之间的速度鸿沟(The processor-memory gap)”</li><li>存储器的访问能力与其存储容量成反比。</li></ul><h2 id="存储器缓存策略"><a href="#存储器缓存策略" class="headerlink" title="存储器缓存策略"></a>存储器缓存策略</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从程序员、设计师和工程师的角度，我们希望系统能够以最快的速度访问所有可用存储器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这个基本上是不可能的，实际上系统并不是使用所有的存储器，而是仅仅是在某些时段内使用某一部分存储器。这个情况下，只需要为程序预留相对最快的存储器，而让那些并非立即执行的代码或者数据使用相对较慢的存储器。当CPU立即需要执行指令时，在执行到存储在较慢的存储器上的代码之前，这些代码会转存在较快的存储器中，这种策略称为”缓存”。</p><p>缓存策略无处不在，横跨多个级别的存储器，如下图所示：</p><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用名为”进程”的抽象概念来表示正在运行的程序。现在多任务操作系统的设计允许一个或者多个用户并发地运行多个程序，对于一个普通用户来说，同时运行多个应用程序（比如听歌、看网页、编辑文档）在正常不过了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过虚拟内存的概念，可以很好的解决内存需求与有限的内存容量之间的矛盾，运行时的物理内存会被划分成数个小的分段（页），每个页都可以用来同步执行程序。正在运行的程序的完整内存布局会被保存在低速存储器（磁盘）中。只有那些当前即将被执行的一部分内存（代码和数据）才会被加载到物理内存页中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要强调的是虚拟内存不同于物理内存，二者属于不同层面的东西。<br>进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。虚拟内存是操作系统内核为了对进程地址空间进行管理(process address space management)而设计的一个逻辑意义上的内存空间概念，我们程序中的指针其实都是这个虚拟内存空间中的地址。</p><div class="note info">            <p><strong>虚拟地址</strong>(virtual address):</p><ul><li>CPU启动保护模式后，程序运行在虚拟地址空间中。</li><li>注意，并不是所有的“程序”都是运行在虚拟地址中。 </li><li>CPU在启动的时候是运行在实模式的，Bootloader以及内核在初始化页表之前并不使用虚拟地址，而是直接使用物理地址的。</li><li>虚拟地址范围：编程模型假定地址空间的范围在0到$2^N$，其中N是32或者64。</li></ul>          </div><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们写完一个C/C++项目之后，采用gcc/g++进行编译，这个时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时程序都没有开始运行，所以何谈物理内存空间地址？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中。既然说虚拟内存是一个逻辑意义上(逻辑存在)的内存空间，为了能够让程序在物理机器上运行起来，那就需要有一套机制可以让这些虚拟内存空间映射到物理内存空间(真实内存条上的空间)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Linux中，解决这个问题的关键是一个叫做 page table (PT页面转换表) 的结构。Linux把物理内存分为了固定统一大小的块，称为page(页)，一般为4KB，并且每个页都有一个编号”page frame number”。这样一个512M大小的内存将包括128K个页。这种方式称为paging，使得操作系统对内存的管理更方便。page table的作用就是将进程操作的地址(虚拟地址)转换成物理地址。</p><p>关于 page table 内容原理，可以参考以下文章。</p><div class="note info">            <p>Linux Page Tables ： <a href="http://www.linux-tutorial.info/modules.php?name=MContent&amp;pageid=307" target="_blank" rel="noopener">www.linux-tutorial.info/modules.php?name=MContent&amp;pageid=307</a></p>          </div><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核会为系统中每一个进程维护一份相互独立的页映射表，页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。</p><p>“页(page)”是虚拟内存空间向物理内存空间映射的基本单元。</p><p>虚拟内存的概念如下图所示：</p><p>上图演示了虚拟内存空间和物理内存空间的相互关系。它们通过Page Table关联起来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中虚拟内存空间中着色部分分别被映射到了物理内存空间对应相同的着色的部分。而虚拟内存空间中灰色的部分表示在物理内存空间中没有与之对应的部分，也就是说灰色部分没有被映射到物理内存空间中。因为虚拟内存空间很大，可能其中很多部分在一次程序运行中根本不需要访问，所以也就没有必要讲虚拟内存空间中的这些部分映射到物理内存空间上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，总结一下，虚拟内存就是一个逻辑存在的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。</p><h3 id="驻留内存"><a href="#驻留内存" class="headerlink" title="驻留内存"></a>驻留内存</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义是指那些被映射到进程虚拟内存空间的物理内存。上图3中，在系统物理内存空间中被着色的部分都是驻留内存。</p><p>比如，A1、A2、A3和A4是进程A的驻留内存；B1、B2和B3是进程B的驻留内存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。</p><div class="note info">            <p>以下为具体示例：</p>          </div><p>操作系统：Linux（Redhat 7.4）</p><h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root(jihaodong)@redhat work]<span class="comment"># free</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      131455940    54627048    12895764      178028    63933128    76268692</span><br><span class="line">Swap:      32767996      134996    32633000</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Key</th><th align="left">Desc</th></tr></thead><tbody><tr><td align="center">Mem.total</td><td align="left">物理内存的总量</td></tr><tr><td align="center">Mem.used</td><td align="left">使用的物理内存的总量</td></tr><tr><td align="center">Mem.free</td><td align="left">空闲内存总量</td></tr><tr><td align="center">Mem.shared</td><td align="left">共享内存</td></tr><tr><td align="center">Mem.buff</td><td align="left">内核缓冲区使用的内存</td></tr><tr><td align="center">Mem.cache</td><td align="left">页面缓存和Slab分配器使用的内存</td></tr><tr><td align="center">Mem.available</td><td align="left">系统空闲内存 Mem.available = Mem.free + Mem.buff + Mem.cache</td></tr><tr><td align="center">Swap.total</td><td align="left">交换分区总大小，系统物理内存不够用时，与swap进行交换</td></tr><tr><td align="center">Swap.used</td><td align="left">已经被使用的交换分区大小</td></tr><tr><td align="center">Swap.free</td><td align="left">未被使用的交换分区大小</td></tr></tbody></table><h3 id="进程的TOP信息："><a href="#进程的TOP信息：" class="headerlink" title="进程的TOP信息："></a>进程的TOP信息：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root(jihaodong)@redhat work]<span class="comment"># top -d 1 </span></span><br><span class="line">top - 14:30:32 up 28 days,  2:25,  1 user,  load average: 0.22, 0.31, 0.25</span><br><span class="line">Tasks: 398 total,   1 running, 397 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.5 us,  0.3 sy,  0.0 ni, 96.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : 13145593+total, 12901476 free, 54629708 used, 63924756 buff/cache</span><br><span class="line">KiB Swap: 32767996 total, 32632996 free,   135000 used. 76267056 avail Mem </span><br><span class="line">  scroll coordinates: y = 1/398 (tasks), x = 1/12 (fields)</span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                            </span><br><span class="line"> 5746 elastic+  20   0  0.233t 0.060t 0.011t S 100.0 48.8   7155:16 /opt/soft/jdk/jdk1.8.0_66/bin/java -Xms48g -Xmx48g -XX:+UseConcMa+ </span><br><span class="line">31299 root      20   0 4283448 305600   2368 S   0.0  0.2  51:26.88 java -XX:PermSize=128m -XX:MaxPermSize=256m -Xms512m -Xmx512m -cp+ </span><br><span class="line"> 7104 elastic+  20   0 1277408  99848   6260 S   0.0  0.1  93:41.92 ./bin/../node/bin/node --no-warnings ./bin/../src/cli              </span><br><span class="line">18809 root      20   0 2921264  47312   4168 S  10.0  0.0 294:00.58 /usr/<span class="built_in">local</span>/bin/xcdc run s1.js                                      </span><br><span class="line">18811 root      20   0 2663044  45584   4124 S   5.0  0.0 286:10.11 /usr/<span class="built_in">local</span>/bin/xcdc run s3.js                                      </span><br><span class="line">18810 root      20   0 2724032  45428   3980 S   5.0  0.0 298:59.47 /usr/<span class="built_in">local</span>/bin/xcdc run s2.js                                      </span><br><span class="line">18813 root      20   0 2930092  44012   4116 S   5.0  0.0 288:44.38 /usr/<span class="built_in">local</span>/bin/xcdc run s5.js                                      </span><br><span class="line">18812 root      20   0 2924452  43312   4024 S   0.0  0.0 291:19.32 /usr/<span class="built_in">local</span>/bin/xcdc run s4.js                                      </span><br><span class="line">10189 root      20   0 2350900  29800   2444 S   0.0  0.0  38:41.39 ./falcon-agent -c cfg.json</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Key</th><th align="left">Desc</th></tr></thead><tbody><tr><td align="center">PID</td><td align="left">进程ID</td></tr><tr><td align="center">PPID</td><td align="left">父进程ID</td></tr><tr><td align="center">UID</td><td align="left">进程所有者的用户ID</td></tr><tr><td align="center">USER</td><td align="left">进程所有者的用户名</td></tr><tr><td align="center">PR</td><td align="left">优先级</td></tr><tr><td align="center">NI</td><td align="left">NICE值，负值表示搞优先级，正值表示优先级底</td></tr><tr><td align="center">VIRT</td><td align="left">进程所用的虚拟内存总量， VIRT = SWAP + RES</td></tr><tr><td align="center">SWAP</td><td align="left">进程使用的虚拟内存中，被置换出去的大小</td></tr><tr><td align="center">RES</td><td align="left">进程使用的，未被置换出去的物理内存，（目前占用物理内存的值）</td></tr><tr><td align="center">SHR</td><td align="left">共享内存大小</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;搞清楚了虚拟内存的概念之后解释VIRT就很简单了，VIRT表示虚拟内存空间大小结合图1(计算机体系结构抽象），对应到图3(虚拟内存空间到物理内存空间的映射）中来说就是A1、A2、A3、A4以及灰色部分所有空间的总和。也就是说虚拟包含了在已经映射到物理内存空间的部分和尚未映射到物理内存空间的部分的总和。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RES的含义是指进程虚拟内存空间中已经映射到物理内存空间的那部分的大小。对应到图1中的进程A来说就是A1、A2、A3以及A4几个部分空间的总和。所以说，看进程在运行过程中占用了多少内存应该看RES的值而不是VIRT的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后来看看SHR所表示的含义。SHR是share（共享）的缩写，它表示的是进程占用的共享内存大小。在上图1中我们看到进程A虚拟内存空间中的A4和进程B虚拟内存空间中的B3都映射到了物理内存空间的A4/B3部分。咋一看很奇怪。为什么会出现这样的情况呢？其实我们写的程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用SHR来表示。某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用RES的值减去SHR值即可。</p><p>这片文章主要简单讲解Linux下进程的内存映射布局。</p><p>内存管理是操作系统的核心; 这对于编程和系统管理都至关重要。</p><h2 id="进程的内存划分方案"><a href="#进程的内存划分方案" class="headerlink" title="进程的内存划分方案"></a>进程的内存划分方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节主要讨论进程内存映射的内部组织细节，我们假定的程序地址空间的范围在0到$2^N$，其中N是32或者64。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的多任务或者多用户操作系统拥有不同的内存映射布局。对于Linux进程的虚拟内存映射来说，其遵循图4所示的映射方案。</p><p>无论平台的进程内存划分方案多么特殊，下面几个内存映射的节(section)都是必须支持的:</p><ul><li>代码节：该段包含了供CPU执行的机器码指令(.text节)。</li><li>数据节：该段包含了供CPU操作的数据。通常来说，初始化数据(.data节)、为初始化数据(.bss节)和只读数据(.rdata节)会保存在分离的节中。</li><li>堆：动态内存分配的区域。</li><li>栈：为各个函数提供了独立的存储空间。</li><li>最上层部分属于内核区域，特定进程的环境变量就存放在该区域。</li></ul><h2 id="二进制文件、编译器、连接器与装载器的作用"><a href="#二进制文件、编译器、连接器与装载器的作用" class="headerlink" title="二进制文件、编译器、连接器与装载器的作用"></a>二进制文件、编译器、连接器与装载器的作用</h2><p>粗略地讲：</p><ul><li>程序的二进制文件中包含了程序运行过程中的内存映射布局的细节。</li><li>链接器创建了二进制文件的整体框架。要实现这项功能，链接器要对编译器生成的二进制文件进行合并，然后想各个内存映射节填充信息(代码和数据等信息)。</li><li>进程内存映射的初始化建立工作是由程序装载器这一系统工具完成的。在最简单的情况下，装载器会打开二进制可执行文件，读取节的相关信息，然后将这些信息载入进程内存映射结构中。</li></ul><p>所有现代操作系统都是按照这种角色分离的方式设计的。</p><p>需要注意的是，以上描述是一个粗略地描述。</p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考:"></a>文章参考:</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1]: 探索 Linux 内存模型： https://www.ibm.com/developerworks/cn/linux/l-memmod/</span><br><span class="line">[2]: 理解VIRT/RES/SHR之间的关系: http://orchome.com/298</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> memory </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP使用Smart Pointer</title>
      <link href="/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/"/>
      <url>/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>他山之石 可以攻玉 – 《诗经·小雅·鹤鸣》</p></blockquote><h2 id="Smart-Pointer-引入原因"><a href="#Smart-Pointer-引入原因" class="headerlink" title="Smart Pointer 引入原因"></a>Smart Pointer 引入原因</h2><p>使用 Raw Pointer 管理动态内存时，经常会遇到这样的问题：</p><ul><li>忘记delete内存，造成内存泄露</li><li>出现异常时，不会执行delete，造成内存泄露</li></ul><p>下面的代码解释了，当一个操作发生异常时，会导致delete不会被执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</span><br><span class="line">    <span class="comment">// 执行一个会抛出异常的操作</span></span><br><span class="line">    func_throw_exception();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++98 中我们需要用一种笨拙的方式，写出异常安全的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        func_throw_exception();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        <span class="keyword">throw</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 使用 Smart Pointer 能轻易写出异常安全的代码，因为当对象退出作用域时, Smart Pointer 将自动调用对象的析构函数，避免内存泄露：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; ptr&#123; <span class="keyword">new</span> Widget &#125;;</span><br><span class="line">    func_throw_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Smart-Pointer-使用方法"><a href="#Smart-Pointer-使用方法" class="headerlink" title="Smart Pointer 使用方法"></a>Smart Pointer 使用方法</h2><p>Smart Pointer 在 <memory> 头文件的 std 名称空间中定义。 它们对于RAII或资源获取初始化编程惯用语至关重要。 这个习惯用法的主要目标是确保资源获取在对象被初始化的同时进行，以便在一行代码中创建和准备对象的所有资源。 实际上，RAII的主要原则是将任何堆分配的资源（例如，动态分配的内存或系统对象句柄）归属给一个堆栈分配的对象，该对象的析构函数包含删除或释放资源的代码， 还有任何相关的清理代码。</p><p>在大多数情况下，初始化 Raw Pointer 或资源句柄以指向实际资源时，请立即将指针传递给Smart Pointer。在现代C++中，Raw Pointer 仅用于有限范围，循环或辅助函数的小代码块，其中性能至关重要，并且不存在对所有权混淆的可能性。</p><p>以下示例将 Raw Pointer 声明与 Smart Pointer 声明进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Raw Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseRawPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 Raw Pointer -- 不推荐 </span></span><br><span class="line">    Song* pSong = <span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pSong...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完成后，不要忘记释放申请的空间</span></span><br><span class="line">    <span class="keyword">delete</span> pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Smart Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseSmartPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在堆栈上声明一个 Smart Pointer 并将其传递给 Raw Pointer  -- 推荐</span></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Song&gt; <span class="title">song2</span><span class="params">(<span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use song2...</span></span><br><span class="line">    <span class="built_in">wstring</span> s = song2-&gt;duration_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// song2 该程序块执行完后自动删除</span></span><br></pre></td></tr></table></figure><p>如示例中所示， Smart Pointer 是您在堆栈中声明的类模板，并使用指向堆分配对象的 Raw Pointer 进行初始化。 Smart Pointer 初始化后，它拥有 Raw Pointer 。这意味着 Smart Pointer 负责删除 Raw Pointer 指定的内存。 Smart Pointer 析构函数包含对删除的调用，并且因为 Smart Pointer 在堆栈中声明，所以当 Smart Pointer 超出作用域时，即使在堆栈之后的某处抛出异常，也会调用析构函数。</p><p>通过使用熟悉的指针操作符 -&gt; 和 * 来访问封装的指针， Smart Pointer 类重载该指针来返回封装的 Raw Pointer 。</p><p>C++ Smart Pointer 的对象创建：您创建对象，然后让系统在正确的时间删除它。不同之处在于没有单独的垃圾收集器在后台运行; 内存通过标准C++范围规则进行管理，以便运行时环境更快，更高效。</p><div class="note info">            <p>总是在单独的代码行上创建Smart Pointer，而不是在参数列表中创建，以便由于某些参数列表分配规则而不会发生细微的资源泄漏。</p>          </div><p>以下示例显示了如何使用标准模板库中的unique_ptrSmart Pointer类型来封装指向大对象的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessLargeObject</span><span class="params">(<span class="keyword">const</span> LargeObject&amp; lo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass a reference to a method.</span></span><br><span class="line">    ProcessLargeObject(*pLarge);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//pLarge is deleted automatically when function block goes out of scope.</span></span><br></pre></td></tr></table></figure><p>该示例演示了使用 Smart Pointer 的以下基本步骤:</p><div class="note info">            <ul><li>将Smart Pointer声明为自动（本地）变量<br>– 不要在Smart Pointer本身上使用new 或 malloc 表达式</li><li>在类型参数中，指定封装指针的指向类型</li><li>将一个Raw Pointer传递给Smart Pointer构造函数中的新对象<br>– Some utility functions or smart pointer constructors do this for you </li><li>使用重载的 -&gt; 和 * 运算符来访问该对象</li><li>让 Smart Pointer 删除对象</li></ul>          </div><p>Smart Pointer 的设计在内存和性能方面尽可能高效。 例如，unique_ptr中唯一的数据成员是封装的指针。 这意味着 unique_ptr 与该指针的大小完全相同，可以是四个字节，也可以是八个字节。 通过使用Smart Pointer重载的 * 和 -&gt; 操作符访问封装的指针不会比直接访问 Raw Pointer 慢得多。</p><p>Smart Pointer有自己的成员函数，可以用“.”符号来访问。 例如，一些STL Smart Pointer有一个 reset member function ，释放指针的所有权。 如果您想在 Smart Pointer 超出范围之前释放 Smart Pointer 所拥有的内存，这非常有用，如下例所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the memory before we exit function block.</span></span><br><span class="line">    pLarge.reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some other work...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Smart-Pointer-类型"><a href="#Smart-Pointer-类型" class="headerlink" title="Smart Pointer 类型"></a>Smart Pointer 类型</h2><ul><li>** unique_ptr **<ul><li>仅允许一个底层指针的所有者</li><li>可以移动到新的所有者，但不能复制或共享</li><li>unique_ptr小而高效, 大小是一个指针</li><li>它支持右值引用，以便从STL集合中快速插入和检索</li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li><li>** shared_ptr **<ul><li>引用计数的Smart Pointer</li><li>当您想要将一个Raw Pointer分配给多个所有者时使用，例如，当您从容器中返回指针的副本但想保留Raw Pointer时。 直到所有shared_ptr所有者超出范围或放弃所有权之后，才会删除Raw Pointer</li><li>大小是两个指针, 一个用于对象，另一个用于包含引用计数的共享控制块</li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li><li>** weak_ptr **<ul><li>与shared_ptr结合使用的特例Smart Pointer</li><li>weak_ptr 提供对一个或多个shared_ptr实例拥有的对象的访问权限，但不参与引用计数</li><li>当你想观察一个物体时使用，但不要求它保持活着。在某些情况下需要中断shared_ptr实例之间的循环引用。 </li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li></ul><h2 id="创建和使用unique-ptr实例"><a href="#创建和使用unique-ptr实例" class="headerlink" title="创建和使用unique_ptr实例"></a>创建和使用unique_ptr实例</h2><p>A unique_ptr不会共享它的指针。 无法将它复制到另一个unique_ptr，（除非它是可修改rvalue） 通过值传递给函数，或需要对其进行复制的任何标准模板库 (STL) 算法中使用。 A unique_ptr只能移动。 这意味着内存资源的所有权将转移到新的unique_ptr和原始unique_ptr不再拥有它。 我们建议您将一个对象限制为一个所有者，因为拥有多个程序逻辑增加复杂性。 因此，当您需要为普通的 C++ 对象的 Smart Pointer ，使用unique_ptr。</p><p>下图说明了两个转让所有权unique_ptr实例。</p><p>移动 unique_ptr 的所有权, unique_ptr在中定义<memory> STL 中的标头。 它是完全有效与 Raw Pointer ，可以使用 STL 容器中。 添加unique_ptr是有效的实例的 STL 容器因为移动构造函数的unique_ptr不需要复制操作。</p><p>** 示例 **<br>下面的示例演示如何创建unique_ptr实例，并在函数之间传递它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Created by Eter J on 2017/12/31.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::Foo\n"</span>; &#125;</span><br><span class="line">    ~Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::~Foo\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::bar\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Foo &amp;foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(const Foo&amp;)\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;  <span class="comment">// p1 owns Foo</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;bar();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">p2</span><span class="params">(<span class="built_in">std</span>::move(p1))</span></span>;  <span class="comment">// now p2 owns Foo</span></span><br><span class="line">        f(*p2);</span><br><span class="line"></span><br><span class="line">        p1 = <span class="built_in">std</span>::move(p2);  <span class="comment">// ownership returns to p1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying p2...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;bar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Foo instance is destroyed when p1 goes out of scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Song&gt; <span class="title">SongFactory</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">wstring</span> artist, <span class="built_in">std</span>::<span class="built_in">wstring</span> title)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implicit move operation into the variable that stores the result. </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(artist, title));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeSongs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new unique_ptr with a new object.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Song&gt; pSong = <span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Mr. Children"</span>, <span class="string">L"Namonaki Uta"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the unique_ptr</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">wstring</span>&gt; titles;</span><br><span class="line">    titles.push_back(pSong-&gt;title);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move raw pointer from one unique_ptr to another.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Song&gt; pSong2 = <span class="built_in">std</span>::move(pSong);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain unique_ptr from function that returns rvalue reference.</span></span><br><span class="line">    <span class="keyword">auto</span> pSong3 = SongFactory(<span class="string">L"Michael Jackson"</span>, <span class="string">L"Beat It"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些例子演示了unique_ptr的基本特征：它可以被移动，但不能被复制。 “移动”将所有权转移到新的unique_ptr并重置旧的unique_ptr。</p><p>以下示例显示如何创建unique_ptr实例并在矢量中使用它们</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SongVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;Song&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a few new unique_ptr&lt;Song&gt; instances </span></span><br><span class="line">    <span class="comment">// and add them to vector using implicit move semantics.</span></span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"B'z"</span>, <span class="string">L"Juice"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Namie Amuro"</span>, <span class="string">L"Funky Town"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Kome Kome Club"</span>, <span class="string">L"Kimi ga Iru Dake de"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Ayumi Hamasaki"</span>, <span class="string">L"Poker Face"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass by reference to lambda body. </span></span><br><span class="line">    for_each(v.begin(), v.end(), [] (<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&lt;Song&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Artist: "</span> &lt;&lt; p-&gt;artist &lt;&lt; <span class="string">L"Title: "</span> &lt;&lt; p-&gt;title &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for_each循环中，请注意unique_ptr是在lambda表达式中通过引用传递的。 如果你尝试在这里传值，编译器会抛出一个错误，因为unique_ptr拷贝构造函数被禁用。</p><p>以下示例显示如何初始化一个类成员unique_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// MyClass owns the unique_ptr.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;ClassFactory&gt; factory;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize by invoking the unique_ptr move constructor.</span></span><br><span class="line">    MyClass() : factory ( <span class="built_in">unique_ptr</span>&lt;ClassFactory&gt;(<span class="keyword">new</span> ClassFactory()))</span><br><span class="line">    &#123;              </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        factory-&gt;DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info">            <ul><li>仅允许一个底层指针的所有者</li><li>可以移动到新的所有者，但不能复制或共享</li></ul>          </div><h2 id="创建和使用shared-ptr实例"><a href="#创建和使用shared-ptr实例" class="headerlink" title="创建和使用shared_ptr实例"></a>创建和使用shared_ptr实例</h2><p>shared_ptr 类型是 Smart Pointer 在为方案设计多个所有者可能必须管理对象生存期内存中的 C++ 标准库中。 在初始化可以将它复制的 shared_ptr 后，将它在函数参数的值，并将其分配给其他 shared_ptr 实例。 所有实例指向同一对象，并且，对“的共享访问控制块”该引用计数的增量和减量，每当新 shared_ptr 添加，超出范围或重新设置。 当引用计数达到零时，控制块删除内存资源和自身。</p><p>下图显示了指向个内存位置的几 shared_ptr 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Eter J on 2017/12/31.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;C&gt; gp;</span><br><span class="line">    &#123;</span><br><span class="line">        C* ptr = <span class="keyword">new</span> C;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;C&gt; <span class="title">sp</span><span class="params">(ptr)</span></span>;</span><br><span class="line">        gp = sp ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp.use_count(): "</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"gp.use_count(): "</span> &lt;&lt; gp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"gp.use_count(): "</span> &lt;&lt; gp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>sp.use_count(): 1<br>gp.use_count(): 2<br>gp.use_count(): 1</p></blockquote><h2 id="创建和使用weak-ptr实例"><a href="#创建和使用weak-ptr实例" class="headerlink" title="创建和使用weak_ptr实例"></a>创建和使用weak_ptr实例</h2><p>有时一个对象必须存储一个访问shared_ptr的底层对象的方法，而不会导致引用计数增加。通常情况下，如果在shared_ptr实例之间有循环引用，则会发生这种情况。</p><p>最好的设计是尽可能避免指针的共享所有权。但是，如果您必须共享shared_ptr实例的所有权，请避免它们之间的循环引用。当循环引用是不可避免的，或者由于某种原因更可取的时候，使用weak_ptr来给一个或多个所有者一个弱引用给另一个shared_ptr。通过使用weak_ptr，您可以创建一个shared_ptr，它将连接到现有的一组相关实例，但前提是基础内存资源仍然有效。 weak_ptr本身不参与引用计数，因此它不能阻止引用计数变为零。但是，可以使用weak_ptr尝试获取初始化的shared_ptr的新副本。如果内存已被删除，则抛出bad_weak_ptr异常。如果内存仍然有效，那么只要shared_ptr变量保持在作用域内，新的共享指针就会增加引用计数并保证内存有效。</p><p>下面的代码示例演示了weak_ptr用于确保正确删除具有循环依赖关系的对象的情况。当你检查这个例子时，假设它只是在考虑了其他解决方案之后才创建的。 Controller对象表示机器进程的某些方面，它们独立运行。每个控制器必须能够随时查询其他控制器的状态，并且每个控制器都包含一个专用矢量<code>&lt;weak_ptr &lt;Controller&gt;&gt;</code>。每个向量包含一个循环引用，因此，使用weak_ptr实例而不是shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Eter J on 2018/1/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    <span class="built_in">wstring</span> Status;</span><br><span class="line">    <span class="built_in">vector</span>&lt;weak_ptr&lt;Controller&gt;&gt; others;</span><br><span class="line">    explicit Controller(int i) : Num(i) , Status(L"On")</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Creating Controller"</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Controller()</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Destroying Controller"</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrates how to test whether the</span></span><br><span class="line">    <span class="comment">// pointed-to memory still exists or not.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckStatuses</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        for_each(others.begin(), others.end(), [] (weak_ptr&lt;Controller&gt; wp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = wp.lock();</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"Status of "</span> &lt;&lt; p-&gt;Num &lt;&lt; <span class="string">" = "</span> &lt;&lt; p-&gt;Status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (bad_weak_ptr b)</span><br><span class="line">            &#123;</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"Null object"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Controller&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">0</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">1</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">2</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">3</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">4</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Each controller depends on all others not being deleted.</span></span><br><span class="line">    <span class="comment">// Give each controller a pointer to all the others.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for_each(v.begin(), v.end(), [v,i] (<span class="built_in">shared_ptr</span>&lt;Controller&gt; p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;Num != i)</span><br><span class="line">            &#123;</span><br><span class="line">                v[i]-&gt;others.push_back(weak_ptr&lt;Controller&gt;(p));</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"push_back to v["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; p-&gt;Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for_each(v.begin(), v.end(), [](<span class="built_in">shared_ptr</span>&lt;Controller&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"use_count = "</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p-&gt;CheckStatuses();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RunTest();</span><br><span class="line">    wcout &lt;&lt; <span class="string">L"Press any key"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>.getline(&amp;ch, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OUTPUT</p><blockquote><p>Creating Controller0<br>Creating Controller1<br>Creating Controller2<br>Creating Controller3<br>Creating Controller4<br>push_back to v[0]: 1<br>push_back to v[0]: 2<br>push_back to v[0]: 3<br>push_back to v[0]: 4<br>push_back to v[1]: 0<br>push_back to v[1]: 2<br>push_back to v[1]: 3<br>push_back to v[1]: 4<br>push_back to v[2]: 0<br>push_back to v[2]: 1<br>push_back to v[2]: 3<br>push_back to v[2]: 4<br>push_back to v[3]: 0<br>push_back to v[3]: 1<br>push_back to v[3]: 2<br>push_back to v[3]: 4<br>push_back to v[4]: 0<br>push_back to v[4]: 1<br>push_back to v[4]: 2<br>push_back to v[4]: 3<br>use_count = 1<br>Status of 1 = On<br>Status of 2 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 2 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 2 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 2 = On<br>Status of 3 = On<br>Destroying Controller4<br>Destroying Controller3<br>Destroying Controller2<br>Destroying Controller1<br>Destroying Controller0<br>Press any key</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> Smart Pointers </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
