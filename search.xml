<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go Micro微服务架构 - 快速上手</title>
      <link href="/2020/03/22/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-003/"/>
      <url>/2020/03/22/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-003/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>A Go microservices development framework  </p></blockquote><h1 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h1><ul><li>依赖</li><li>安装</li><li>编写服务</li></ul><a id="more"></a><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><strong>Protobuf</strong></p><p>代码生成依赖 Protobuf , 安装示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/micro/protoc-gen-micro/v2</span><br></pre></td></tr></table></figure><p><strong>Discovery</strong></p><p>推荐使用 etcd 作为注册中心。</p><p><strong>etcd</strong></p><p>单机部署参考 Dockerfile, 安装示例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM k8s.gcr.io/debian-base:v1.0.0</span><br><span class="line"></span><br><span class="line">ADD etcd /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">ADD etcdctl /usr/<span class="built_in">local</span>/bin/</span><br><span class="line">RUN mkdir -p /var/etcd/</span><br><span class="line">RUN mkdir -p /var/lib/etcd/</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alpine Linux doesn't use pam, which means that there is no /etc/nsswitch.conf,</span></span><br><span class="line"><span class="comment"># but Golang relies on /etc/nsswitch.conf to check the order of DNS resolving</span></span><br><span class="line"><span class="comment"># (see https://github.com/golang/go/commit/9dee7771f561cf6aee081c0af6658cc81fac3918)</span></span><br><span class="line"><span class="comment"># To fix this we just create /etc/nsswitch.conf and add the following line:</span></span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">'hosts: files mdns4_minimal [NOTFOUND=return] dns mdns4'</span> &gt;&gt; /etc/nsswitch.conf</span><br><span class="line"></span><br><span class="line">EXPOSE 2379 2380</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define default command.</span></span><br><span class="line">CMD [<span class="string">"/usr/local/bin/etcd"</span>]</span><br></pre></td></tr></table></figure><p>使用当前目录作为上下文的构建命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build .</span><br></pre></td></tr></table></figure><h2 id="安装-go-micro"><a href="#安装-go-micro" class="headerlink" title="安装 go-micro"></a>安装 go-micro</h2><p>Go Micro是用于基于Go的开发的框架。</p><p>服务中导入 go-micro 示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/micro/go-micro/v2"</span></span><br></pre></td></tr></table></figure><p>建议开启 go mod，并通过 go mod 启用改功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enable go modules</span></span><br><span class="line"><span class="built_in">export</span> GO111MODULE=on</span><br><span class="line"><span class="comment"># initialise go modules in your app</span></span><br><span class="line">go mod init</span><br><span class="line"><span class="comment"># now go get</span></span><br><span class="line">go get ./...</span><br></pre></td></tr></table></figure><h2 id="编写服务"><a href="#编写服务" class="headerlink" title="编写服务"></a>编写服务</h2><p>按照惯例，使用 go-micro 编写一个 helloworld服务，以下是具体步骤。</p><ul><li>服务原型</li><li>生成原型</li><li>编写服务</li><li>运行服务</li><li>定义客户端</li><li>运行客户端</li></ul><blockquote><p>以下操作均在 greeter 目录下进行。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cd /home/eter/greeter</span></span><br></pre></td></tr></table></figure><h3 id="服务原型"><a href="#服务原型" class="headerlink" title="服务原型"></a>服务原型</h3><p>创建 proto 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir proto</span></span><br><span class="line"><span class="comment"># touch proto/greeter.proto</span></span><br></pre></td></tr></table></figure><p>编辑 proto/greeter.proto 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">service Greeter &#123;</span><br><span class="line">rpc Hello(HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">string greeting &#x3D; 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看下 greeter 目录，可以看到 proto 目录中只有 greeter.proto 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── proto</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h3 id="生成原型"><a href="#生成原型" class="headerlink" title="生成原型"></a>生成原型</h3><p>在定义好原型后我们得使用 protoc ，以及 micro 插件编译它，micro 插件可以帮助生成 go micro 需要的原型文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=<span class="variable">$GOPATH</span>/src:. --micro_out=. --go_out=. proto/greeter.proto</span><br></pre></td></tr></table></figure><p>查看下 greeter 目录，可以看到 proto 目录中生成的文件 greeter.pb.go 以及 greeter.pb.micro.go 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h3 id="编写服务-1"><a href="#编写服务-1" class="headerlink" title="编写服务"></a>编写服务</h3><ol><li>首先编辑greeter的服务代码 main.go 文件</li></ol><p>主要功能:</p><ul><li>定义并实现Greeter Handler中的接口</li><li>初始化 micro.Service</li><li>注册 Greeter Handler</li><li>运行服务</li></ul><p>main.go 代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">micro <span class="string">"github.com/micro/go-micro/v2"</span></span><br><span class="line">proto <span class="string">"github.com/eopenio/greeter/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Greeter <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *Greeter)</span> <span class="title">Hello</span><span class="params">(ctx context.Context, req *proto.HelloRequest, rsp *proto.HelloResponse)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">rsp.Greeting = <span class="string">"Hello "</span> + req.Name</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建新的服务</span></span><br><span class="line">service := micro.NewService(</span><br><span class="line">    micro.Name(<span class="string">"greeter"</span>),</span><br><span class="line">    micro.Version(<span class="string">"v0.0.1"</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化服务，并且解析命令行传参</span></span><br><span class="line">service.Init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterGreeterHandler</span></span><br><span class="line">proto.RegisterGreeterHandler(service.Server(), <span class="built_in">new</span>(Greeter))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务</span></span><br><span class="line"><span class="keyword">if</span> err := service.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看下 greeter 目录，可以看到新增 main.go 文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">### 运行服务</span><br><span class="line">&#96;&#96;&#96; bash</span><br><span class="line"># go run main.go</span><br><span class="line">2020-03-22 20:57:40  level&#x3D;info Starting [service] greeter</span><br><span class="line">2020-03-22 20:57:40  level&#x3D;info Server [grpc] Listening on [::]:65461</span><br><span class="line">2020-03-22 20:57:40  level&#x3D;info Registry [etcd] Registering node: greeter-45fc8d75-1db5-48f0-8f5d-71a691e5c982</span><br></pre></td></tr></table></figure><p>通过 micro 命令进行查看服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># micro list services</span><br><span class="line">greeter</span><br><span class="line"></span><br><span class="line"># micro get service greeter</span><br><span class="line">service  greeter</span><br><span class="line"></span><br><span class="line">version v0.0.1</span><br><span class="line"></span><br><span class="line">ID      Address Metadata</span><br><span class="line">greeter-45fc8d75-1db5-48f0-8f5d-71a691e5c982    192.168.3.5:65461       transport&#x3D;grpc,broker&#x3D;eats,protocol&#x3D;grpc,registry&#x3D;etcd,server&#x3D;grpc</span><br><span class="line"></span><br><span class="line">Endpoint: Greeter.Hello</span><br><span class="line"></span><br><span class="line">Request: &#123;</span><br><span class="line">        name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Response: &#123;</span><br><span class="line">        greeting string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义客户端"><a href="#定义客户端" class="headerlink" title="定义客户端"></a>定义客户端</h3><p>新增客户端代码 cli.go 文件。</p><p>cli.go 代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"context"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">micro <span class="string">"github.com/micro/go-micro/v2"</span></span><br><span class="line">proto <span class="string">"github.com/eopenio/greeter/proto"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建新服务</span></span><br><span class="line">service := micro.NewService(micro.Name(<span class="string">"greeter.client"</span>))</span><br><span class="line">service.Init()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新的客户端</span></span><br><span class="line">greeter := proto.NewGreeterService(<span class="string">"greeter"</span>, service.Client())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用greeter</span></span><br><span class="line">rsp, err := greeter.Hello(context.TODO(), &amp;proto.HelloRequest&#123;Name: <span class="string">"World"</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印响应请求</span></span><br><span class="line">fmt.Println(rsp.Greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">greeter</span><br><span class="line">├── cli.go</span><br><span class="line">├── go.mod</span><br><span class="line">├── go.sum</span><br><span class="line">├── main.go</span><br><span class="line">└── proto</span><br><span class="line">    ├── greeter.pb.go</span><br><span class="line">    ├── greeter.pb.micro.go</span><br><span class="line">    └── greeter.proto</span><br></pre></td></tr></table></figure><h3 id="运行客户端"><a href="#运行客户端" class="headerlink" title="运行客户端"></a>运行客户端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">go</span> run cli.<span class="keyword">go</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><blockquote><p>本文示例可以通过以下命令，进行编译.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone https://github.com/eopenio/greeter.git</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务端</span></span><br><span class="line"><span class="comment"># go run main.go</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line"><span class="comment"># go run cli.go</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go Micro </tag>
            
            <tag> Go </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Micro微服务架构特性</title>
      <link href="/2020/03/14/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-002/"/>
      <url>/2020/03/14/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-002/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>A Go microservices development framework  </p></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Go Micro 是微服务开发的框架。</p><blockquote><p>Go Micro 提供了分布式系统开发的核心要求，包括 RPC 和事件驱动的通信。 微哲学是可插拔体系结构的默认设置。 我们提供了默认设置，可帮助您快速入门，但所有内容都可以轻松换出。</p></blockquote><a id="more"></a><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>Go Micro 主要功能：</p><ul><li><p>服务发现（Service Discovery）- 自动服务注册和名称解析，服务发现是微服务开发的核心。 当服务A需要与服务B通信时，它需要该服务的位置。 默认发现机制是多播 DNS（mdns），一种零配置系统，推荐使用 etcd 。</p></li><li><p>负载平衡（Load Balancing）- 基于服务发现的客户端负载平衡。 当获得了服务的任意数量的实例的地址，我们现在需要一种方法来确定要路由到的节点。 我们使用随机散列负载平衡来提供服务之间的平均分配，并在出现问题时重试其他节点。</p></li><li><p>消息编码 （Message Encoding）- 基于内容类型的动态消息编码。 客户端和服务端会一起使用content-type的格式来对Go进行无缝编/解码。各种各样的消息被编码会发送到不同的客户端，客户端服服务端默认会处理这些消息。 默认情况下，包括protobuf 和 json 。</p></li><li><p>请求/响应 (Request/Response) - 基于 RPC 的请求/响应，支持双向流。 我们为同步通信提供了一个抽象。 对服务的请求将被自动解决，负载均衡，拨号和流式传输。 默认传输方式是gRPC 。</p></li><li><p>异步消息传递（Async Messaging） - 发布订阅（PubSub）头等功能内置在异步通信与事件驱动架构中。事件通知在微服务开发中处于核心位置。默认的消息传送使用点到点http/1.1，激活tls时则使用http2。</p></li><li><p>可插拔接口（Pluggable Interfaces）- Go Micro对每个分布式系统抽象都使用Go接口。 因此，这些接口是可插入的，并允许Go Micro与运行时无关。 您可以插入任何基础技术。 在github.com/micro/go-plugins中找到插件。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go Micro </tag>
            
            <tag> Go </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TiKV is busy 处理思路</title>
      <link href="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/"/>
      <url>/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Server is Busy  </p></blockquote><p>日常 TiDB 运维中，当你在 TiKV 监控 Trouble - Shooting - Server Is Busy 看到以下这样的监控时，</p><img src="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/1.png" class="" title="[1] 图片"><p>可能此时的 TiDB 集群在该时间段内响应延时会大幅度增加，甚至会出现大量请求超时并且伴随大量告警出现。</p><a id="more"></a><h1 id="Server-is-Busy-的影响"><a href="#Server-is-Busy-的影响" class="headerlink" title="Server is Busy 的影响"></a>Server is Busy 的影响</h1><p>Server is Busy 本质上就是 tikv-server 繁忙，暂时无法对该请求做出响应，所以此时从TiDB集群到业务都会受到影响。以下从两个角度观察这个问题。</p><h2 id="运维角度"><a href="#运维角度" class="headerlink" title="运维角度"></a>运维角度</h2><ol><li>集群性能迅速下降，现象可以从 TiDB 监控 - Query Summary - Duration 明显看到。</li><li>TIKV 服务器负载增加，现象可以从 TiKV 监控 - Server / Thread CPU / Error 中看到。</li><li>TiDB 日志中大量的 server is busy 日志，可以查看 tidb.log 过滤 Server is Busy 关键字。</li><li>慢查询大量增加，常规基于主键查询的请求，也会很慢。<h2 id="业务角度"><a href="#业务角度" class="headerlink" title="业务角度"></a>业务角度</h2></li><li>业务访问数据库响应耗时大幅度增加， 例如： 5ms -&gt; 5s。</li><li>业务告警，数据库访问超时，例如： TimeoutException。</li><li>部分请求访问DB不响应。</li></ol><p>每次出现 Server is Busy 对于运维以及业务都是比较紧张，那么接下来分析一下 Server is busy 的原因。</p><h1 id="Server-is-Busy-的原因"><a href="#Server-is-Busy-的原因" class="headerlink" title="Server is Busy 的原因"></a>Server is Busy 的原因</h1><h2 id="写保护-write-stall"><a href="#写保护-write-stall" class="headerlink" title="写保护 ( write stall )"></a>写保护 ( write stall )</h2><p>TiKV 底层有 2 个 RocksDB 作为存储,  RocksDB 使用的 LSM Tree，LSM Tree 牺牲了一部分读的性能和增加了合并的开销，换取了高效的写性能，但如果写入过快，超过了 RocksDB 处理的极限，RocksDB 就会考虑对写入进行降速处理。</p><ul><li>密集写入，导致 level0 sst 太多导致 stall 。</li><li>pending compaction bytes 太多导致 stall ， 服务器磁盘IO能力在写入高峰跟不上写入。</li><li>memtable 太多导致 stall 。</li></ul><img src="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/2.png" class="" title="[1] 图片"><blockquote><p><strong>处理建议：</strong><br><strong>1.  **</strong>是否存在热点写入/写入倾斜，是否可以打散写入**<br><strong>2. 调整 rocksdb 参数 max-sub-compactions 至 2~3，将 level0 到 level1 的 compaction 拆分为多个子任务，加快并行 compaction 的速度</strong><br><strong>3. 适当调大 level0-slowdown-writes-trigger = 40，level0-stop-writes-trigger = 56，这不一定能根本解决问题，只是加大了限制进行缓解</strong></p></blockquote><h2 id="scheduler-too-busy"><a href="#scheduler-too-busy" class="headerlink" title="scheduler too busy"></a>scheduler too busy</h2><ul><li><p>写入冲突严重，两阶段提交时都需要申请 latch，如果冲突严重，latch 申请就会排队，导致 latch wait duration 比较高, 现象 TIKV 监控 -  scheduler prewrite|commit 的 latch wait duration</p><p>scheduler prewrite - latch wait duration  | scheduler commit latch wait duration</p><img src="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/3.png" class="" title="[1] 图片"> <img src="/2020/03/07/%E6%95%B0%E6%8D%AE%E5%BA%93/TiDB/tikv-is-busy/4.png" class="" title="[1] 图片"></li><li><p>写入慢导致写入堆积，该 TiKV 正在写入的数据超过了 [storage] scheduler-pending-write-threshold = “100MB” 设置的阈值。</p><blockquote><p><strong>处理建议：</strong><br><strong>1. **</strong>是否可以将针对单行数据的并行写入，改为串行写入，**<br><strong>2. **</strong>可以考虑分布式锁，**<br><strong>3. **</strong>开启悲观事务。**</p></blockquote><h2 id="线程池排队"><a href="#线程池排队" class="headerlink" title="线程池排队"></a>线程池排队</h2><p>常规的线程池设计中，请求处理的越快，线程池压力越小，整体处理能力就越强。当单个请求变慢时，整个线程池也不受影响，当变慢的请求逐渐堆积时，整个线程池也会逐渐变得处理能力下降甚至不响应。超出线程池上限后会返回 Server Is Busy。</p></li><li><p><strong>关键配置 tikv.yml</strong></p></li></ul><p>在 3.0 的版本中，不同的查询会在 2 套线程池中执行，分别是 <strong>readpool.storage 和 readpool.coprocessor</strong>，每个线程池分为三个优先级，分别用于处理高优先级，普通优先级和低优先级请求。 TiDB 点查选择是高优先级，范围扫描是普通优先级，而诸如表分析之类的后台作业是低优先级。</p><p>既然是使用线程池处理请求，接下来看下线程池的限制，线程数，以及单个线程允许积压的最大任务数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 高优先级线程池, 默认值 cpu core 数 * 80%, 最小值 1</span><br><span class="line">high-concurrency</span><br><span class="line">&#x2F;&#x2F; 普通优先级线程池, 默认值 cpu core 数 * 80%, 最小值 1</span><br><span class="line">normal-concurrency</span><br><span class="line">&#x2F;&#x2F; 低优先级线程池, 默认值 cpu core 数 * 80%, 最小值 1</span><br><span class="line">low-concurrency</span><br><span class="line">&#x2F;&#x2F; 指定低优先级线程池中每个线程的最大运行操作数，处理高优先级读取请求</span><br><span class="line">&#x2F;&#x2F; 默认值 2000, 最小值 2000</span><br><span class="line">max-tasks-per-worker-high</span><br><span class="line">&#x2F;&#x2F; 指定低优先级线程池中每个线程的最大运行操作数，处理低普通先级读取请求</span><br><span class="line">max-tasks-per-worker-normal</span><br><span class="line">&#x2F;&#x2F; 指定低优先级线程池中每个线程的最大运行操作数，处理低优先级读取请求</span><br><span class="line">max-tasks-per-worker-low</span><br></pre></td></tr></table></figure><p>其中以高优先线程池为例，因为调整线程资源的是线程池级别而不是单线程级别，所以高优先级线程池默认最大运行操作数的限制为  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-tasks-per-worker-high * high-concurrency &#x3D; 2000 * 4 &#x3D; 8000</span><br></pre></td></tr></table></figure><p><strong>推荐配置（针对**</strong> <strong><strong>TiDB</strong></strong> <strong>**集群）</strong></p><ul><li>单机单实例( TiKV )，不应超过服务器 CPU 核数<ul><li>例如：一台 48 Core 服务器运行 1 个 tikv-server，则每个实例的高并发值应小于 48</li><li>最大性能推荐值：<strong>48</strong></li><li>均衡性能推荐值：<strong>36</strong></li></ul></li><li>单机多实例(TIKV)，<ul><li>例如：一台 48 Core 服务器运行 3 个 tikv-server，则每个实例的高并发值应小于 16</li><li>最大性能推荐值：<strong>16</strong></li><li>均衡性能推荐值：<strong>12</strong></li><li><strong>4.0 的线程池整合</strong></li></ul></li></ul><p>从 4.0 版本开始，将 readpool.storage 和 readpool.coprocessor  整合为一个 unified read pool 线程池，并且不再需要配置3 个优先级，解决资源分配不均的问题，并且大大提高了使用体验，相关配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[readpool]</span><br><span class="line"># unify-read-pool &#x3D; true</span><br><span class="line"></span><br><span class="line">[readpool.unified]</span><br><span class="line"># min-thread-count &#x3D; 1</span><br><span class="line"># max-thread-count &#x3D; 8</span><br><span class="line"></span><br><span class="line">## Size of the stack for each thread in the thread pool.</span><br><span class="line"># stack-size &#x3D; &quot;10MB&quot;</span><br><span class="line"></span><br><span class="line">## Max running tasks of each worker, reject if exceeded.</span><br><span class="line"># max-tasks-per-worker &#x3D; 2000</span><br></pre></td></tr></table></figure><blockquote><p><strong>处理建议：</strong><br><strong>1.  考虑是否出现大量扫描现象。</strong><br><strong>2. 考虑是否是可用线程较少，可以通过增加**</strong> <strong><strong>TIKV</strong></strong> ***<em>节点提高集群整体处理能力 *</em></p></blockquote><h2 id="raftstore-is-busy"><a href="#raftstore-is-busy" class="headerlink" title="raftstore is busy"></a>raftstore is busy</h2><ul><li>append log 遇到了 stall，监控在 2 个地方可以看到<ul><li>[tikv-detail]-&gt;[RocksDB - raft]-[Write stall duration]</li><li>[tikv-detail]-&gt;[RocksDB - kv]-[Write stall duration]</li><li>以上也可以直接看 [tikv-detail]-&gt;[Errors]-&gt;[Server is busy]</li></ul></li><li>append log duration 比较高，导致处理消息不及时，监控在 [tikv-detail]-&gt;[Raft IO]-&gt;[append log duration]<ul><li>考虑 append log 慢， 查看磁盘 IO 情况， 通常是写盘慢了，查看 [tikv-detail]-&gt;[Raft IO]-&gt;[Write duration]</li><li>考虑 [raftstore] store-pool-size 配置是否过小， 该值建议在[1,5] 之间，不建议太大。可以通过 [tikv-detail]-&gt;[Thread CPU]-&gt;[Raft store CPU] 看确定是否过小，如果[Raft store CPU] 超过了 [store-pool-size 数量] * 70% 说明需要加大 store-pool-size。</li><li>通常单个 tikv-server 实例的 region 数量超过 5 万之后，region 之间的心跳也会占用很多 raftstore cpu ，建议开启 hibernate region 来解决这个问题<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[raftstore]</span><br><span class="line">hibernate-regions &#x3D; true</span><br></pre></td></tr></table></figure><blockquote><p><strong>处理建议：</strong><br><strong>考虑是否磁盘写入存在瓶颈</strong><br><strong>是否**</strong> <strong>**store-pool-size 配置是否过小，适当调整参数</strong></p></blockquote></li></ul></li></ul><p>以上为 TiKV Server is busy 的主要的几个原因，在使用 TiDB 过程中需要尽力避免过程中出现 Server is Busy 的情况，可以通过优化 SQL 优化、参数调整、增加节点等手段避免该问题。</p><h1 id="触发-Server-is-Busy-的常见场景"><a href="#触发-Server-is-Busy-的常见场景" class="headerlink" title="触发 Server is Busy 的常见场景"></a>触发 Server is Busy 的常见场景</h1><h2 id="SQL-开销较大"><a href="#SQL-开销较大" class="headerlink" title="SQL** 开销较大**"></a><strong>SQL**</strong> 开销较大**</h2><ol><li>常规慢查询,  有很多的场景，例如：全表扫描。</li><li>大表索引未被命中正确的索引的情况。</li><li>高并发导入数据，导致 tikv 写入繁忙。<blockquote><p><strong>处理建议：</strong><br><strong>针对开销较大的 SQL，如果是读 SQL可以做相应的 SQL 优化，来避免大量扫表。（4.0 的 unified thread pool 针对这种情况有优化）。高并发导入的问题可以降低导入并发。</strong></p></blockquote><h2 id="事务冲突"><a href="#事务冲突" class="headerlink" title="事务冲突"></a><strong>事务冲突</strong></h2>乐观锁事务模式下事务冲突严重，会导致大量的线程进行重试，从而导致 tikv is busy，例如计数器功能。</li></ol><blockquote><p><strong>处理建议：</strong><br><strong>针对**</strong>乐观锁事务模式下的事务<strong>**冲突的场景，可以通过添加分布式锁，或者使用悲观事务模型来解决。</strong><br><strong>TiDB v3.0.8默认使用悲观锁事务模式，如果集群是从 v3.0.8 版本以下升级上来的集群，默认还是乐观锁事务模式。</strong></p></blockquote><h2 id="集群-region-数量太大"><a href="#集群-region-数量太大" class="headerlink" title="集群** region **数量太大"></a><strong>集群**</strong> <strong><strong>region</strong></strong> <strong>**数量太大</strong></h2><p>在 TiDB 2.1 等低版本中，因为 TiKV 的 raft 是单线程，当管理的 region 数达到一定量级时，性能会下降，多大一定程度，单核只够管理 region 。并没有空闲的能力处理业务。业务就会出现 server is busy。</p><blockquote><p><strong>处理建议：</strong><br><strong>1. 升级到 3.0 版本以上，设置 store-pool-size 开启多线程 raftstore</strong><br><strong>2. 设置 hibernate-regions ，开启静默 region</strong></p></blockquote><h2 id="热点问题"><a href="#热点问题" class="headerlink" title="热点问题"></a>热点问题</h2><ol><li>如果业务写入集中在某一个 region 范围内，比如自增 id 的写入，这个 region 所在的 tikv-server 的压力会增大，导致线程处理变慢，线程会出现排队，最终导致 server is busy。</li><li>客户端在短期内发起密集的写入，其中主要是热点写入，可能出现写入倾斜，并导致单个 tikv 节点出现 server is busy。<blockquote><p><strong>处理建议：</strong><br><strong>对于热点更新的场景，可以通过 region 拆分、shard_row_id_bits、pre_split_regions 等方式优化。</strong></p></blockquote><h1 id="常规查询变慢的原因"><a href="#常规查询变慢的原因" class="headerlink" title="常规查询变慢的原因"></a>常规查询变慢的原因</h1>当 Server is Busy 出现后，查询为什么突然变慢，平时 99% 6ms 返回, 为啥突然 3s 都没有返回?</li></ol><p>如果确认是在 Server is Busy 的情况下，Query Duration 明显增加，此时可以通过观察 tidb.log 日志，可以看到，正常查询主要耗时在 wait 阶段，并不是消耗在 exec 时间。</p><p>例如：</p><p>如果 coprocessor 的每个线程排队超过 2000 个任务，本次查询是第 2001 个任务，那么需要队列中任务任一个任务执行完成，后第 2001 才会开始执行，所以看似简单的查询会变慢，主要时间消耗在队列等待上面。</p><h1 id="总结处理思路"><a href="#总结处理思路" class="headerlink" title="总结处理思路"></a>总结处理思路</h1><p>通过前面的原因和场景，总结一下可能的处理思路及手段如下：</p><ol><li>针对开销较大的 SQL，可以做出相应的 SQL 优化，来避免大量扫表。（4.0 的 unified thread pool 针对这种情况有优化）</li><li>针对事务冲突的场景，可以通过添加分布式锁，或者使用悲观事务模型来解决。</li><li>对于热点更新的场景，可以通过 region 拆分、shard_row_id_bits、pre_split_regions等方式优化。</li><li>如果是可用的线程较少，导致了线程池排队，可以增加 tikv 节点，来提高集群的处理能力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> TiDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> TiDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Micro微服务架构组成</title>
      <link href="/2020/02/25/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001/"/>
      <url>/2020/02/25/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>A Go microservices development framework  </p></blockquote><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>提供的主要软件是Micro ，一个微服务开发运行时。</p><blockquote><p>Micro 解决了构建微服务系统的关键需求。 它采用微服务架构模式并将其转换为一组工具，这些工具充当可伸缩平台的构建块。Micro隐藏了分布式系统的复杂性，并为开发人员提供了易于理解的概念。</p></blockquote><a id="more"></a><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>运行时由以下功能组成：</p><img src="/2020/02/25/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1/go-micro/go-micro-001/micro-001-01.png" class="" title="[1] micro运行时提供的功能"><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>一个api网关。 使用服务发现进行动态请求路由的单个入口点。 API网关使您可以在后端构建可扩展的微服务架构，并在前端整合服务公共api的服务。 微型api通过发现和可插入处理程序提供强大的路由，以服务http，grpc，websocket，发布事件等。</p><h3 id="bot"><a href="#bot" class="headerlink" title="bot"></a>bot</h3><p>在您的平台上运行的slackbot，可让您从Slack本身管理应用程序。 微型机器人启用了ChatOps，并使您能够通过消息与团队一起完成所有工作。 它还具有将松弛命令创建为动态发现的服务的功能。</p><h3 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h3><p>交互式CLI，用于从终端描述，查询和直接与您的平台和服务交互。 CLI为您提供了您希望了解微服务正在发生的所有命令。 它还包括一个交互模式。</p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>使用微网络服务构建多云网络。 只需插入并连接任何环境中的网络服务，并创建一个单一的扁平网络即可进行全球路由。 微型网络会根据您在每个数据中心中的本地注册表动态地构建路由，以确保查询是根据位置进行路由的。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>服务模板生成器。 创建新的服务模板以快速入门。 Micro提供了用于编写微服务的预定义模板。 始终以相同的方式开始，构建相同的服务以提高生产力。</p><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>基于Go Micro构建的透明服务代理。 将服务发现，负载平衡，容错，消息编码，中间件，监视等卸载到一个位置。 独立运行它或与您的服务一起运行。</p><h3 id="tunnel"><a href="#tunnel" class="headerlink" title="tunnel"></a>tunnel</h3><p>无需任何VPN即可在任何环境中访问服务的网络隧道。 微隧道通过内置代理提供点对点隧道，以查询远程环境中的服务。 从本地笔记本电脑查询生产系统。</p><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>Web仪表板使您可以浏览服务，描述其端点，请求和响应格式，甚至直接查询它们。 仪表板还包括内置的CLI（类似CLI），适用于希望即时进入终端的开发人员。</p><p>另外，micro提供了Go开发框架：</p><h3 id="go-micro"><a href="#go-micro" class="headerlink" title="go-micro"></a>go-micro</h3><p>利用强大的Go Micro框架轻松快速地开发微服务。Go Micro消除了分布式系统的复杂性，并提供了更简单的抽象来构建高度可扩展的微服务。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
          <category> 微服务 </category>
          
          <category> go-micro </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go Micro </tag>
            
            <tag> Go </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年更新计划</title>
      <link href="/2020/02/01/%E9%9A%8F%E7%AC%94/hello-2020/"/>
      <url>/2020/02/01/%E9%9A%8F%E7%AC%94/hello-2020/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>坚持不懈 始终如一</p></blockquote><div class="note info">            <ul><li>研究go-micro微服务架构</li><li>研究ClickHouse</li><li>MySQL 8.0上线</li><li>MongoDB 4.2上线</li><li>Codis上云</li></ul>          </div><hr>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译和链接</title>
      <link href="/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/"/>
      <url>/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>认识自己的无知是认识世界的最可靠的方法 –《随笔集》 </p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个程序的的生命周期从编写源代码开始，在编写完源代码之后，就可以进行代码的构建了。其中第一步就是编译,编译阶段会生成各文件的目标文件，将生成的目标文件和系统库文件进行链接，最终生成了可以在特定平台运行的可执行文件。最后操作系统装载器会加载、解包这些数据，并将这些数据用于程序的执行阶段。</p><div class="note info">            <p>程序的生命周期简化</p><ul><li>编写源代码</li><li>编译</li><li>链接</li><li>装载</li><li>执行</li></ul>          </div><a id="more"></a><h1 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从广义上来讲，编译就是讲一种编程语言源代码转换为另一种编程语言描述的源代码。</p><ul><li>编译器负责编译程序。</li><li>编译器的输入时一个编译单元。通常编译单元指的是一个包含源代码的文本文件。</li><li>一个程序通常包含多个编译单元。</li><li>编译过程的输出是一系列二进制目标文件的集合，其中每一个目标文件对应一个作为输入的编译单元。</li></ul><p>我们通常会遇到以下几个相关概念：</p><ul><li>编译：从严格意义上讲，编译指的是讲高级语言编写的源代码翻译成低级语言描述代码的过程。</li><li>交叉编译：如果在一个平台(相同CPU或者操作系统)上进行的编译，生成的代码可以在其他平台上面执行，那么这种编译过程就称为交叉编译。</li><li>反编译：降低级语言编写的源代码转换成高级语言描述的源代码的过程。</li></ul><h2 id="编译的各个阶段"><a href="#编译的各个阶段" class="headerlink" title="编译的各个阶段"></a>编译的各个阶段</h2><ol><li>预处理阶段</li><li>语言分析阶段</li><li>汇编阶段</li><li>优化阶段</li><li>代码生成阶段</li></ol><h2 id="目标文件属性"><a href="#目标文件属性" class="headerlink" title="目标文件属性"></a>目标文件属性</h2><p>编译阶段的输出是一个或者多个目标文件，以下分析这些目标文件的结构。</p><ul><li>目标文件是通过其对应的源代码编译得到。</li><li>符号(symbol)和节(section)是目标文件的基本组成部分，其中符号表示的是程序中的内存地址或者数据内存。绝大多数的目标文件中包含代码节(.text)、初始化数据节(.data)、未初始化数据节(.bss)以及一些特殊节(比如试调信息等)。</li><li>构建程序的目的在于将编译的每个独立的源代码文件生成节拼接到一个二进制可执行文件中。最终生成的二进制文件中包含了多个相同类型的节(.text、.data 和 .bss节等)，而这些节是从每个独立的目标文件中拼接得到的。</li><li>目标文件中独立的节都可能包含在最终的程序内存映射中，因此目标文件中每个节的起始地址都会被临时设置成0，等待连接时调整。在程序构建过程的后续阶段(链接阶段)中会确认程序内存映射中每个独立节的实际地址范围。</li><li>在将目标文件的节拼接到程序内存映射的过程中。其中唯一重要的参数是节的长度，准确的说是节的地址范围。</li><li>目标文件中不包含专门的节会影响堆和栈中的数据。内存映射中的堆和栈内容完全在运行时确定，除了需要指定堆和栈的默认长度以外，并不需要程序指定任何其他初始化设置。</li><li>目标文件只包含了程序.bss(未初始化数据)节的基本信息， 而.bss节本身也仅仅只有字节的长度信息。装载器会利用这有限的数据为.bss节建立足够其数据存储的内存空间。</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来讲，目标文件中的信息是根据一组特定的二进制格式规范集合进行存储的，其中范围定义了多种不同平台的细节信息。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二进制格式规范的设计通常是为了支持C/C++语言结构并帮助其解决实现问题。二进制格式规范常常会涵盖各种各样的文件类型，比如可执行文件、静态库和动态库等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Linux上，可执行和可链接格式(Executable and Linkable Format, ELF)已经得到了普遍运用。在Windows上，二进制文件通常遵循PE/COFF格式规范。</p><div class="note info">            <h2 id="为什么要进行编译？"><a href="#为什么要进行编译？" class="headerlink" title="为什么要进行编译？"></a>为什么要进行编译？</h2><p>答：<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前很多语言实现了一阶段式构建过程, 比如：python，javaScripts。<br>为了程序构建阶段支持复用(此处指的是二进制级别的复用)，所以将程序构建分为两个阶段(编译阶段和链接阶段)。</p>          </div><h1 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h1><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接过程第一个阶段仅仅进行拼接，其过程是将分散在单独目标文件中不同类型的节拼接到程序内存映射节中。</p><p>如下图所示：</p><img src="/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/link-01.png" class="" title="图1 链接第一步： 重定向"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了完成该任务，需要将之前预留的空间，也就是节中从0开始的地址范围转换成最终程序的内存映射中更具体的地址范围。</p><h2 id="解析引用"><a href="#解析引用" class="headerlink" title="解析引用"></a>解析引用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将节的地址范围转换成程序内存映射地址范围，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc -c function.c main.c</span></span><br><span class="line"><span class="meta"># gcc funtion.o main.o -o demoApp</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc function.c main.c -o demoApp</span></span><br></pre></td></tr></table></figure><p>反汇编main.o文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># objdump -D -M intel main.o</span></span><br></pre></td></tr></table></figure><p>对含有未初始化数据的.bss节进行反汇编操作，发现变量nCompletionStatus</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># objdump -x -j .bss demoApp</span></span><br></pre></td></tr></table></figure><h1 id="可执行文件属性"><a href="#可执行文件属性" class="headerlink" title="可执行文件属性"></a>可执行文件属性</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;链接过程的最终结果是二进制可执行文件，其结构布局遵循特定目标平台的可执行文件格式。</p><p>启动代码有两种不同形式：</p><ul><li>crt0 是程序入口点，这是程序代码的第一部分，在内核控制下执行。</li><li>crt1 是启动例程(startuproutine)，可以在main函数执行前与程序终止后完成一些任务。</li></ul><p>程序可执行文件的整体结构大致如下图：</p><img src="/2018/01/08/%E7%BC%96%E7%A8%8B/%E7%BC%96%E8%AF%91/compile-and-link/link-02.png" class="" title="图2 可执行文件的整体结构"><h2 id="各种节的类型"><a href="#各种节的类型" class="headerlink" title="各种节的类型"></a>各种节的类型</h2><p>待补充…</p><h2 id="各种符号类型"><a href="#各种符号类型" class="headerlink" title="各种符号类型"></a>各种符号类型</h2><p>待补充…</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 编译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译 </tag>
            
            <tag> 链接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从存储器到内存映射布局</title>
      <link href="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/"/>
      <url>/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>就算影子也会在黑暗的时候离开</p></blockquote><p>在日常工作中，经常会有同学提出这样的问题，</p><ul><li>“我的程序运行时究竟占用了多大的内存?”</li><li>“我的程序占用的虚拟内存非常大，这个正常么?”</li></ul><div class="note info">            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文主要从以下几个方向，深入浅出的说明内存的基本布局，后续会更新内存的管理的文章。</p><ul><li>计算机体系结构</li><li>存储器缓存策略</li><li>虚拟内存</li><li>虚拟地址</li><li>进程的内存划分方案</li></ul>          </div><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;计算机技术领域的变化日新月异，集成电路技术带来的元件不仅种类繁多，而且在功能方面还在不断改进增强。按照摩尔定律，集成电路上可容纳的晶体管数目大约每两年便会增加一倍。而与晶体管数据量密切相关的处理能力也将提升一倍。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经验告诉我们，想要应对这种快速的变化，就是在经常变动的实现层次之上，利用抽象和泛华的方法为计算机系统定义全局目标和结构体系。这种方法的核心在于描述抽象的方式，该方式要确保在去除相对无关的实现细节后，任何新的实现与核心定义都能保持一致。</p><p>整个计算机体系结构可用下图表示:</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/os_abstract.png" class=""><a id="more"></a><p>在计算机系统中，有一些和存储器相关的趣事：</p><ul><li>人们对存储器容量总是无法满足，而且存储器容量总是供不应求。</li><li>存储器技术似乎是导致处理器性能障碍的主要原因<br>– 这种被称为”处理器和存储器之间的速度鸿沟(The processor-memory gap)”</li><li>存储器的访问能力与其存储容量成反比。</li></ul><h2 id="存储器缓存策略"><a href="#存储器缓存策略" class="headerlink" title="存储器缓存策略"></a>存储器缓存策略</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从程序员、设计师和工程师的角度，我们希望系统能够以最快的速度访问所有可用存储器。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这个基本上是不可能的，实际上系统并不是使用所有的存储器，而是仅仅是在某些时段内使用某一部分存储器。这个情况下，只需要为程序预留相对最快的存储器，而让那些并非立即执行的代码或者数据使用相对较慢的存储器。当CPU立即需要执行指令时，在执行到存储在较慢的存储器上的代码之前，这些代码会转存在较快的存储器中，这种策略称为”缓存”。</p><p>缓存策略无处不在，横跨多个级别的存储器，如下图所示：</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/memory_en.png" class=""><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们用名为”进程”的抽象概念来表示正在运行的程序。现在多任务操作系统的设计允许一个或者多个用户并发地运行多个程序，对于一个普通用户来说，同时运行多个应用程序（比如听歌、看网页、编辑文档）在正常不过了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过虚拟内存的概念，可以很好的解决内存需求与有限的内存容量之间的矛盾，运行时的物理内存会被划分成数个小的分段（页），每个页都可以用来同步执行程序。正在运行的程序的完整内存布局会被保存在低速存储器（磁盘）中。只有那些当前即将被执行的一部分内存（代码和数据）才会被加载到物理内存页中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要强调的是虚拟内存不同于物理内存，二者属于不同层面的东西。<br>进程占用虚拟内存空间大并非意味着程序的物理内存也一定占用很大。虚拟内存是操作系统内核为了对进程地址空间进行管理(process address space management)而设计的一个逻辑意义上的内存空间概念，我们程序中的指针其实都是这个虚拟内存空间中的地址。</p><div class="note info">            <p><strong>虚拟地址</strong>(virtual address):</p><ul><li>CPU启动保护模式后，程序运行在虚拟地址空间中。</li><li>注意，并不是所有的“程序”都是运行在虚拟地址中。 </li><li>CPU在启动的时候是运行在实模式的，Bootloader以及内核在初始化页表之前并不使用虚拟地址，而是直接使用物理地址的。</li><li>虚拟地址范围：编程模型假定地址空间的范围在0到$2^N$，其中N是32或者64。</li></ul>          </div><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们写完一个C/C++项目之后，采用gcc/g++进行编译，这个时候编译器采用的地址其实就是虚拟内存空间的地址。因为这时程序都没有开始运行，所以何谈物理内存空间地址？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡是程序运行过程中可能需要用到的指令或者数据都必须在虚拟内存空间中。既然说虚拟内存是一个逻辑意义上(逻辑存在)的内存空间，为了能够让程序在物理机器上运行起来，那就需要有一套机制可以让这些虚拟内存空间映射到物理内存空间(真实内存条上的空间)。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Linux中，解决这个问题的关键是一个叫做 page table (PT页面转换表) 的结构。Linux把物理内存分为了固定统一大小的块，称为page(页)，一般为4KB，并且每个页都有一个编号”page frame number”。这样一个512M大小的内存将包括128K个页。这种方式称为paging，使得操作系统对内存的管理更方便。page table的作用就是将进程操作的地址(虚拟地址)转换成物理地址。</p><p>关于 page table 内容原理，可以参考以下文章。</p><div class="note info">            <p>Linux Page Tables ： <a href="http://www.linux-tutorial.info/modules.php?name=MContent&amp;pageid=307" target="_blank" rel="noopener">www.linux-tutorial.info/modules.php?name=MContent&amp;pageid=307</a></p>          </div><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内核会为系统中每一个进程维护一份相互独立的页映射表，页映射表的基本原理是将程序运行过程中需要访问的一段虚拟内存空间通过页映射表映射到一段物理内存空间上，这样CPU访问对应虚拟内存地址的时候就可以通过这种查找页映射表的机制访问物理内存上的某个对应的地址。</p><p>“页(page)”是虚拟内存空间向物理内存空间映射的基本单元。</p><p>虚拟内存的概念如下图所示：</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/system-physical-memory.png" class="" title="图3 虚拟内存空间到物理内存空间的映射"><p>上图演示了虚拟内存空间和物理内存空间的相互关系。它们通过Page Table关联起来。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中虚拟内存空间中着色部分分别被映射到了物理内存空间对应相同的着色的部分。而虚拟内存空间中灰色的部分表示在物理内存空间中没有与之对应的部分，也就是说灰色部分没有被映射到物理内存空间中。因为虚拟内存空间很大，可能其中很多部分在一次程序运行中根本不需要访问，所以也就没有必要讲虚拟内存空间中的这些部分映射到物理内存空间上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，总结一下，虚拟内存就是一个逻辑存在的内存空间，在程序运行过程中虚拟内存空间中需要被访问的部分会被映射到物理内存空间。虚拟内存空间大只能表示程序运行过程中可访问的空间比较大，不代表物理内存空间占用也大。</p><h3 id="驻留内存"><a href="#驻留内存" class="headerlink" title="驻留内存"></a>驻留内存</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顾名思义是指那些被映射到进程虚拟内存空间的物理内存。上图3中，在系统物理内存空间中被着色的部分都是驻留内存。</p><p>比如，A1、A2、A3和A4是进程A的驻留内存；B1、B2和B3是进程B的驻留内存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程的驻留内存就是进程实实在在占用的物理内存。一般我们所讲的进程占用了多少内存，其实就是说的占用了多少驻留内存而不是多少虚拟内存。因为虚拟内存大并不意味着占用的物理内存大。</p><div class="note info">            <p>以下为具体示例：</p>          </div><p>操作系统：Linux（Redhat 7.4）</p><h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root(jihaodong)@redhat work]<span class="comment"># free</span></span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:      131455940    54627048    12895764      178028    63933128    76268692</span><br><span class="line">Swap:      32767996      134996    32633000</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Key</th><th align="left">Desc</th></tr></thead><tbody><tr><td align="center">Mem.total</td><td align="left">物理内存的总量</td></tr><tr><td align="center">Mem.used</td><td align="left">使用的物理内存的总量</td></tr><tr><td align="center">Mem.free</td><td align="left">空闲内存总量</td></tr><tr><td align="center">Mem.shared</td><td align="left">共享内存</td></tr><tr><td align="center">Mem.buff</td><td align="left">内核缓冲区使用的内存</td></tr><tr><td align="center">Mem.cache</td><td align="left">页面缓存和Slab分配器使用的内存</td></tr><tr><td align="center">Mem.available</td><td align="left">系统空闲内存 Mem.available = Mem.free + Mem.buff + Mem.cache</td></tr><tr><td align="center">Swap.total</td><td align="left">交换分区总大小，系统物理内存不够用时，与swap进行交换</td></tr><tr><td align="center">Swap.used</td><td align="left">已经被使用的交换分区大小</td></tr><tr><td align="center">Swap.free</td><td align="left">未被使用的交换分区大小</td></tr></tbody></table><h3 id="进程的TOP信息："><a href="#进程的TOP信息：" class="headerlink" title="进程的TOP信息："></a>进程的TOP信息：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root(jihaodong)@redhat work]<span class="comment"># top -d 1 </span></span><br><span class="line">top - 14:30:32 up 28 days,  2:25,  1 user,  load average: 0.22, 0.31, 0.25</span><br><span class="line">Tasks: 398 total,   1 running, 397 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s):  3.5 us,  0.3 sy,  0.0 ni, 96.2 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line">KiB Mem : 13145593+total, 12901476 free, 54629708 used, 63924756 buff/cache</span><br><span class="line">KiB Swap: 32767996 total, 32632996 free,   135000 used. 76267056 avail Mem </span><br><span class="line">  scroll coordinates: y = 1/398 (tasks), x = 1/12 (fields)</span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                            </span><br><span class="line"> 5746 elastic+  20   0  0.233t 0.060t 0.011t S 100.0 48.8   7155:16 /opt/soft/jdk/jdk1.8.0_66/bin/java -Xms48g -Xmx48g -XX:+UseConcMa+ </span><br><span class="line">31299 root      20   0 4283448 305600   2368 S   0.0  0.2  51:26.88 java -XX:PermSize=128m -XX:MaxPermSize=256m -Xms512m -Xmx512m -cp+ </span><br><span class="line"> 7104 elastic+  20   0 1277408  99848   6260 S   0.0  0.1  93:41.92 ./bin/../node/bin/node --no-warnings ./bin/../src/cli              </span><br><span class="line">18809 root      20   0 2921264  47312   4168 S  10.0  0.0 294:00.58 /usr/<span class="built_in">local</span>/bin/xcdc run s1.js                                      </span><br><span class="line">18811 root      20   0 2663044  45584   4124 S   5.0  0.0 286:10.11 /usr/<span class="built_in">local</span>/bin/xcdc run s3.js                                      </span><br><span class="line">18810 root      20   0 2724032  45428   3980 S   5.0  0.0 298:59.47 /usr/<span class="built_in">local</span>/bin/xcdc run s2.js                                      </span><br><span class="line">18813 root      20   0 2930092  44012   4116 S   5.0  0.0 288:44.38 /usr/<span class="built_in">local</span>/bin/xcdc run s5.js                                      </span><br><span class="line">18812 root      20   0 2924452  43312   4024 S   0.0  0.0 291:19.32 /usr/<span class="built_in">local</span>/bin/xcdc run s4.js                                      </span><br><span class="line">10189 root      20   0 2350900  29800   2444 S   0.0  0.0  38:41.39 ./falcon-agent -c cfg.json</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">Key</th><th align="left">Desc</th></tr></thead><tbody><tr><td align="center">PID</td><td align="left">进程ID</td></tr><tr><td align="center">PPID</td><td align="left">父进程ID</td></tr><tr><td align="center">UID</td><td align="left">进程所有者的用户ID</td></tr><tr><td align="center">USER</td><td align="left">进程所有者的用户名</td></tr><tr><td align="center">PR</td><td align="left">优先级</td></tr><tr><td align="center">NI</td><td align="left">NICE值，负值表示搞优先级，正值表示优先级底</td></tr><tr><td align="center">VIRT</td><td align="left">进程所用的虚拟内存总量， VIRT = SWAP + RES</td></tr><tr><td align="center">SWAP</td><td align="left">进程使用的虚拟内存中，被置换出去的大小</td></tr><tr><td align="center">RES</td><td align="left">进程使用的，未被置换出去的物理内存，（目前占用物理内存的值）</td></tr><tr><td align="center">SHR</td><td align="left">共享内存大小</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;搞清楚了虚拟内存的概念之后解释VIRT就很简单了，VIRT表示虚拟内存空间大小结合图1(计算机体系结构抽象），对应到图3(虚拟内存空间到物理内存空间的映射）中来说就是A1、A2、A3、A4以及灰色部分所有空间的总和。也就是说虚拟包含了在已经映射到物理内存空间的部分和尚未映射到物理内存空间的部分的总和。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RES的含义是指进程虚拟内存空间中已经映射到物理内存空间的那部分的大小。对应到图1中的进程A来说就是A1、A2、A3以及A4几个部分空间的总和。所以说，看进程在运行过程中占用了多少内存应该看RES的值而不是VIRT的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后来看看SHR所表示的含义。SHR是share（共享）的缩写，它表示的是进程占用的共享内存大小。在上图1中我们看到进程A虚拟内存空间中的A4和进程B虚拟内存空间中的B3都映射到了物理内存空间的A4/B3部分。咋一看很奇怪。为什么会出现这样的情况呢？其实我们写的程序会依赖于很多外部的动态库（.so），比如libc.so、libld.so等等。这些动态库在内存中仅仅会保存/映射一份，如果某个进程运行时需要这个动态库，那么动态加载器会将这块内存映射到对应进程的虚拟内存空间中。多个进展之间通过共享内存的方式相互通信也会出现这样的情况。这么一来，就会出现不同进程的虚拟内存空间会映射到相同的物理内存空间。这部分物理内存空间其实是被多个进程所共享的，所以我们将他们称为共享内存，用SHR来表示。某个进程占用的内存除了和别的进程共享的内存之外就是自己的独占内存了。所以要计算进程独占内存的大小只要用RES的值减去SHR值即可。</p><p>这片文章主要简单讲解Linux下进程的内存映射布局。</p><p>内存管理是操作系统的核心; 这对于编程和系统管理都至关重要。</p><h2 id="进程的内存划分方案"><a href="#进程的内存划分方案" class="headerlink" title="进程的内存划分方案"></a>进程的内存划分方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本节主要讨论进程内存映射的内部组织细节，我们假定的程序地址空间的范围在0到$2^N$，其中N是32或者64。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的多任务或者多用户操作系统拥有不同的内存映射布局。对于Linux进程的虚拟内存映射来说，其遵循图4所示的映射方案。</p><img src="/2018/01/04/Linux/%E5%86%85%E5%AD%98/memory-standard-segment-layout/linux-process-memory.png" class="" title="图3 虚拟内存空间到物理内存空间的映射"><p>无论平台的进程内存划分方案多么特殊，下面几个内存映射的节(section)都是必须支持的:</p><ul><li>代码节：该段包含了供CPU执行的机器码指令(.text节)。</li><li>数据节：该段包含了供CPU操作的数据。通常来说，初始化数据(.data节)、为初始化数据(.bss节)和只读数据(.rdata节)会保存在分离的节中。</li><li>堆：动态内存分配的区域。</li><li>栈：为各个函数提供了独立的存储空间。</li><li>最上层部分属于内核区域，特定进程的环境变量就存放在该区域。</li></ul><h2 id="二进制文件、编译器、连接器与装载器的作用"><a href="#二进制文件、编译器、连接器与装载器的作用" class="headerlink" title="二进制文件、编译器、连接器与装载器的作用"></a>二进制文件、编译器、连接器与装载器的作用</h2><p>粗略地讲：</p><ul><li>程序的二进制文件中包含了程序运行过程中的内存映射布局的细节。</li><li>链接器创建了二进制文件的整体框架。要实现这项功能，链接器要对编译器生成的二进制文件进行合并，然后想各个内存映射节填充信息(代码和数据等信息)。</li><li>进程内存映射的初始化建立工作是由程序装载器这一系统工具完成的。在最简单的情况下，装载器会打开二进制可执行文件，读取节的相关信息，然后将这些信息载入进程内存映射结构中。</li></ul><p>所有现代操作系统都是按照这种角色分离的方式设计的。</p><p>需要注意的是，以上描述是一个粗略地描述。</p><h2 id="文章参考"><a href="#文章参考" class="headerlink" title="文章参考:"></a>文章参考:</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[1]: 探索 Linux 内存模型： https://www.ibm.com/developerworks/cn/linux/l-memmod/</span><br><span class="line">[2]: 理解VIRT/RES/SHR之间的关系: http://orchome.com/298</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> 内存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 内存 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP使用Smart Pointer</title>
      <link href="/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/"/>
      <url>/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>他山之石 可以攻玉 – 《诗经·小雅·鹤鸣》</p></blockquote><h2 id="Smart-Pointer-引入原因"><a href="#Smart-Pointer-引入原因" class="headerlink" title="Smart Pointer 引入原因"></a>Smart Pointer 引入原因</h2><p>使用 Raw Pointer 管理动态内存时，经常会遇到这样的问题：</p><ul><li>忘记delete内存，造成内存泄露</li><li>出现异常时，不会执行delete，造成内存泄露</li></ul><p>下面的代码解释了，当一个操作发生异常时，会导致delete不会被执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</span><br><span class="line">    <span class="comment">// 执行一个会抛出异常的操作</span></span><br><span class="line">    func_throw_exception();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++98 中我们需要用一种笨拙的方式，写出异常安全的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = <span class="keyword">new</span> Widget;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        func_throw_exception();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        <span class="keyword">throw</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11 使用 Smart Pointer 能轻易写出异常安全的代码，因为当对象退出作用域时, Smart Pointer 将自动调用对象的析构函数，避免内存泄露：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Widget&gt; ptr&#123; <span class="keyword">new</span> Widget &#125;;</span><br><span class="line">    func_throw_exception();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Smart-Pointer-使用方法"><a href="#Smart-Pointer-使用方法" class="headerlink" title="Smart Pointer 使用方法"></a>Smart Pointer 使用方法</h2><p>Smart Pointer 在 <memory> 头文件的 std 名称空间中定义。 它们对于RAII或资源获取初始化编程惯用语至关重要。 这个习惯用法的主要目标是确保资源获取在对象被初始化的同时进行，以便在一行代码中创建和准备对象的所有资源。 实际上，RAII的主要原则是将任何堆分配的资源（例如，动态分配的内存或系统对象句柄）归属给一个堆栈分配的对象，该对象的析构函数包含删除或释放资源的代码， 还有任何相关的清理代码。</p><p>在大多数情况下，初始化 Raw Pointer 或资源句柄以指向实际资源时，请立即将指针传递给Smart Pointer。在现代C++中，Raw Pointer 仅用于有限范围，循环或辅助函数的小代码块，其中性能至关重要，并且不存在对所有权混淆的可能性。</p><p>以下示例将 Raw Pointer 声明与 Smart Pointer 声明进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Raw Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseRawPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 Raw Pointer -- 不推荐 </span></span><br><span class="line">    Song* pSong = <span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use pSong...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完成后，不要忘记释放申请的空间</span></span><br><span class="line">    <span class="keyword">delete</span> pSong;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Smart Pointer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UseSmartPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在堆栈上声明一个 Smart Pointer 并将其传递给 Raw Pointer  -- 推荐</span></span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;Song&gt; <span class="title">song2</span><span class="params">(<span class="keyword">new</span> Song(<span class="string">L"Nothing on You"</span>, <span class="string">L"Bruno Mars"</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use song2...</span></span><br><span class="line">    <span class="built_in">wstring</span> s = song2-&gt;duration_;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// song2 该程序块执行完后自动删除</span></span><br></pre></td></tr></table></figure><p>如示例中所示， Smart Pointer 是您在堆栈中声明的类模板，并使用指向堆分配对象的 Raw Pointer 进行初始化。 Smart Pointer 初始化后，它拥有 Raw Pointer 。这意味着 Smart Pointer 负责删除 Raw Pointer 指定的内存。 Smart Pointer 析构函数包含对删除的调用，并且因为 Smart Pointer 在堆栈中声明，所以当 Smart Pointer 超出作用域时，即使在堆栈之后的某处抛出异常，也会调用析构函数。</p><p>通过使用熟悉的指针操作符 -&gt; 和 * 来访问封装的指针， Smart Pointer 类重载该指针来返回封装的 Raw Pointer 。</p><p>C++ Smart Pointer 的对象创建：您创建对象，然后让系统在正确的时间删除它。不同之处在于没有单独的垃圾收集器在后台运行; 内存通过标准C++范围规则进行管理，以便运行时环境更快，更高效。</p><div class="note info">            <p>总是在单独的代码行上创建Smart Pointer，而不是在参数列表中创建，以便由于某些参数列表分配规则而不会发生细微的资源泄漏。</p>          </div><p>以下示例显示了如何使用标准模板库中的unique_ptrSmart Pointer类型来封装指向大对象的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeObject</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProcessLargeObject</span><span class="params">(<span class="keyword">const</span> LargeObject&amp; lo)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass a reference to a method.</span></span><br><span class="line">    ProcessLargeObject(*pLarge);</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//pLarge is deleted automatically when function block goes out of scope.</span></span><br></pre></td></tr></table></figure><p>该示例演示了使用 Smart Pointer 的以下基本步骤:</p><div class="note info">            <ul><li>将Smart Pointer声明为自动（本地）变量<br>– 不要在Smart Pointer本身上使用new 或 malloc 表达式</li><li>在类型参数中，指定封装指针的指向类型</li><li>将一个Raw Pointer传递给Smart Pointer构造函数中的新对象<br>– Some utility functions or smart pointer constructors do this for you </li><li>使用重载的 -&gt; 和 * 运算符来访问该对象</li><li>让 Smart Pointer 删除对象</li></ul>          </div><p>Smart Pointer 的设计在内存和性能方面尽可能高效。 例如，unique_ptr中唯一的数据成员是封装的指针。 这意味着 unique_ptr 与该指针的大小完全相同，可以是四个字节，也可以是八个字节。 通过使用Smart Pointer重载的 * 和 -&gt; 操作符访问封装的指针不会比直接访问 Raw Pointer 慢得多。</p><p>Smart Pointer有自己的成员函数，可以用“.”符号来访问。 例如，一些STL Smart Pointer有一个 reset member function ，释放指针的所有权。 如果您想在 Smart Pointer 超出范围之前释放 Smart Pointer 所拥有的内存，这非常有用，如下例所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmartPointerDemo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the object and pass it to a smart pointer</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;LargeObject&gt; <span class="title">pLarge</span><span class="params">(<span class="keyword">new</span> LargeObject())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Call a method on the object</span></span><br><span class="line">    pLarge-&gt;DoSomething();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Free the memory before we exit function block.</span></span><br><span class="line">    pLarge.reset();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some other work...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Smart-Pointer-类型"><a href="#Smart-Pointer-类型" class="headerlink" title="Smart Pointer 类型"></a>Smart Pointer 类型</h2><ul><li>** unique_ptr **<ul><li>仅允许一个底层指针的所有者</li><li>可以移动到新的所有者，但不能复制或共享</li><li>unique_ptr小而高效, 大小是一个指针</li><li>它支持右值引用，以便从STL集合中快速插入和检索</li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li><li>** shared_ptr **<ul><li>引用计数的Smart Pointer</li><li>当您想要将一个Raw Pointer分配给多个所有者时使用，例如，当您从容器中返回指针的副本但想保留Raw Pointer时。 直到所有shared_ptr所有者超出范围或放弃所有权之后，才会删除Raw Pointer</li><li>大小是两个指针, 一个用于对象，另一个用于包含引用计数的共享控制块</li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li><li>** weak_ptr **<ul><li>与shared_ptr结合使用的特例Smart Pointer</li><li>weak_ptr 提供对一个或多个shared_ptr实例拥有的对象的访问权限，但不参与引用计数</li><li>当你想观察一个物体时使用，但不要求它保持活着。在某些情况下需要中断shared_ptr实例之间的循环引用。 </li><li>头文件：<code>&lt;memory&gt;</code></li></ul></li></ul><h2 id="创建和使用unique-ptr实例"><a href="#创建和使用unique-ptr实例" class="headerlink" title="创建和使用unique_ptr实例"></a>创建和使用unique_ptr实例</h2><p>A unique_ptr不会共享它的指针。 无法将它复制到另一个unique_ptr，（除非它是可修改rvalue） 通过值传递给函数，或需要对其进行复制的任何标准模板库 (STL) 算法中使用。 A unique_ptr只能移动。 这意味着内存资源的所有权将转移到新的unique_ptr和原始unique_ptr不再拥有它。 我们建议您将一个对象限制为一个所有者，因为拥有多个程序逻辑增加复杂性。 因此，当您需要为普通的 C++ 对象的 Smart Pointer ，使用unique_ptr。</p><p>下图说明了两个转让所有权unique_ptr实例。</p><img src="/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/unique_ptr.png" class="" title="unique_ptr"><p>移动 unique_ptr 的所有权, unique_ptr在中定义<memory> STL 中的标头。 它是完全有效与 Raw Pointer ，可以使用 STL 容器中。 添加unique_ptr是有效的实例的 STL 容器因为移动构造函数的unique_ptr不需要复制操作。</p><p>** 示例 **<br>下面的示例演示如何创建unique_ptr实例，并在函数之间传递它们。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Created by Eter J on 2017/12/31.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::Foo\n"</span>; &#125;</span><br><span class="line">    ~Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::~Foo\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Foo::bar\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Foo &amp;foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(const Foo&amp;)\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;  <span class="comment">// p1 owns Foo</span></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;bar();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Foo&gt; <span class="title">p2</span><span class="params">(<span class="built_in">std</span>::move(p1))</span></span>;  <span class="comment">// now p2 owns Foo</span></span><br><span class="line">        f(*p2);</span><br><span class="line"></span><br><span class="line">        p1 = <span class="built_in">std</span>::move(p2);  <span class="comment">// ownership returns to p1</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroying p2...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1) p1-&gt;bar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Foo instance is destroyed when p1 goes out of scope</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;Song&gt; <span class="title">SongFactory</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">wstring</span> artist, <span class="built_in">std</span>::<span class="built_in">wstring</span> title)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Implicit move operation into the variable that stores the result. </span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(artist, title));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MakeSongs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new unique_ptr with a new object.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Song&gt; pSong = <span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Mr. Children"</span>, <span class="string">L"Namonaki Uta"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the unique_ptr</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">wstring</span>&gt; titles;</span><br><span class="line">    titles.push_back(pSong-&gt;title);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move raw pointer from one unique_ptr to another.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;Song&gt; pSong2 = <span class="built_in">std</span>::move(pSong);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Obtain unique_ptr from function that returns rvalue reference.</span></span><br><span class="line">    <span class="keyword">auto</span> pSong3 = SongFactory(<span class="string">L"Michael Jackson"</span>, <span class="string">L"Beat It"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些例子演示了unique_ptr的基本特征：它可以被移动，但不能被复制。 “移动”将所有权转移到新的unique_ptr并重置旧的unique_ptr。</p><p>以下示例显示如何创建unique_ptr实例并在矢量中使用它们</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SongVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unique_ptr</span>&lt;Song&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a few new unique_ptr&lt;Song&gt; instances </span></span><br><span class="line">    <span class="comment">// and add them to vector using implicit move semantics.</span></span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"B'z"</span>, <span class="string">L"Juice"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Namie Amuro"</span>, <span class="string">L"Funky Town"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Kome Kome Club"</span>, <span class="string">L"Kimi ga Iru Dake de"</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">unique_ptr</span>&lt;Song&gt;(<span class="keyword">new</span> Song(<span class="string">L"Ayumi Hamasaki"</span>, <span class="string">L"Poker Face"</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass by reference to lambda body. </span></span><br><span class="line">    for_each(v.begin(), v.end(), [] (<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&lt;Song&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Artist: "</span> &lt;&lt; p-&gt;artist &lt;&lt; <span class="string">L"Title: "</span> &lt;&lt; p-&gt;title &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    &#125;);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for_each循环中，请注意unique_ptr是在lambda表达式中通过引用传递的。 如果你尝试在这里传值，编译器会抛出一个错误，因为unique_ptr拷贝构造函数被禁用。</p><p>以下示例显示如何初始化一个类成员unique_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// MyClass owns the unique_ptr.</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;ClassFactory&gt; factory;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize by invoking the unique_ptr move constructor.</span></span><br><span class="line">    MyClass() : factory ( <span class="built_in">unique_ptr</span>&lt;ClassFactory&gt;(<span class="keyword">new</span> ClassFactory()))</span><br><span class="line">    &#123;              </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        factory-&gt;DoSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info">            <ul><li>仅允许一个底层指针的所有者</li><li>可以移动到新的所有者，但不能复制或共享</li></ul>          </div><h2 id="创建和使用shared-ptr实例"><a href="#创建和使用shared-ptr实例" class="headerlink" title="创建和使用shared_ptr实例"></a>创建和使用shared_ptr实例</h2><p>shared_ptr 类型是 Smart Pointer 在为方案设计多个所有者可能必须管理对象生存期内存中的 C++ 标准库中。 在初始化可以将它复制的 shared_ptr 后，将它在函数参数的值，并将其分配给其他 shared_ptr 实例。 所有实例指向同一对象，并且，对“的共享访问控制块”该引用计数的增量和减量，每当新 shared_ptr 添加，超出范围或重新设置。 当引用计数达到零时，控制块删除内存资源和自身。</p><p>下图显示了指向个内存位置的几 shared_ptr 实例。</p><img src="/2018/01/01/%E7%BC%96%E7%A8%8B/CPP/cpp_smart_ptr/shared_ptr.png" class="" title="shared_ptr"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Eter J on 2017/12/31.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;C&gt; gp;</span><br><span class="line">    &#123;</span><br><span class="line">        C* ptr = <span class="keyword">new</span> C;</span><br><span class="line">        <span class="function"><span class="built_in">shared_ptr</span>&lt;C&gt; <span class="title">sp</span><span class="params">(ptr)</span></span>;</span><br><span class="line">        gp = sp ;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"sp.use_count(): "</span> &lt;&lt; sp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"gp.use_count(): "</span> &lt;&lt; gp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"gp.use_count(): "</span> &lt;&lt; gp.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OUTPUT:</p><blockquote><p>sp.use_count(): 1<br>gp.use_count(): 2<br>gp.use_count(): 1</p></blockquote><h2 id="创建和使用weak-ptr实例"><a href="#创建和使用weak-ptr实例" class="headerlink" title="创建和使用weak_ptr实例"></a>创建和使用weak_ptr实例</h2><p>有时一个对象必须存储一个访问shared_ptr的底层对象的方法，而不会导致引用计数增加。通常情况下，如果在shared_ptr实例之间有循环引用，则会发生这种情况。</p><p>最好的设计是尽可能避免指针的共享所有权。但是，如果您必须共享shared_ptr实例的所有权，请避免它们之间的循环引用。当循环引用是不可避免的，或者由于某种原因更可取的时候，使用weak_ptr来给一个或多个所有者一个弱引用给另一个shared_ptr。通过使用weak_ptr，您可以创建一个shared_ptr，它将连接到现有的一组相关实例，但前提是基础内存资源仍然有效。 weak_ptr本身不参与引用计数，因此它不能阻止引用计数变为零。但是，可以使用weak_ptr尝试获取初始化的shared_ptr的新副本。如果内存已被删除，则抛出bad_weak_ptr异常。如果内存仍然有效，那么只要shared_ptr变量保持在作用域内，新的共享指针就会增加引用计数并保证内存有效。</p><p>下面的代码示例演示了weak_ptr用于确保正确删除具有循环依赖关系的对象的情况。当你检查这个例子时，假设它只是在考虑了其他解决方案之后才创建的。 Controller对象表示机器进程的某些方面，它们独立运行。每个控制器必须能够随时查询其他控制器的状态，并且每个控制器都包含一个专用矢量<code>&lt;weak_ptr &lt;Controller&gt;&gt;</code>。每个向量包含一个循环引用，因此，使用weak_ptr实例而不是shared_ptr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by Eter J on 2018/1/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    <span class="built_in">wstring</span> Status;</span><br><span class="line">    <span class="built_in">vector</span>&lt;weak_ptr&lt;Controller&gt;&gt; others;</span><br><span class="line">    explicit Controller(int i) : Num(i) , Status(L"On")</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Creating Controller"</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Controller()</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"Destroying Controller"</span> &lt;&lt; Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrates how to test whether the</span></span><br><span class="line">    <span class="comment">// pointed-to memory still exists or not.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CheckStatuses</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        for_each(others.begin(), others.end(), [] (weak_ptr&lt;Controller&gt; wp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = wp.lock();</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"Status of "</span> &lt;&lt; p-&gt;Num &lt;&lt; <span class="string">" = "</span> &lt;&lt; p-&gt;Status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">catch</span> (bad_weak_ptr b)</span><br><span class="line">            &#123;</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"Null object"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RunTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Controller&gt;&gt; v;</span><br><span class="line"></span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">0</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">1</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">2</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">3</span>)));</span><br><span class="line">    v.push_back(<span class="built_in">shared_ptr</span>&lt;Controller&gt;(<span class="keyword">new</span> Controller(<span class="number">4</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Each controller depends on all others not being deleted.</span></span><br><span class="line">    <span class="comment">// Give each controller a pointer to all the others.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; v.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        for_each(v.begin(), v.end(), [v,i] (<span class="built_in">shared_ptr</span>&lt;Controller&gt; p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;Num != i)</span><br><span class="line">            &#123;</span><br><span class="line">                v[i]-&gt;others.push_back(weak_ptr&lt;Controller&gt;(p));</span><br><span class="line">                wcout &lt;&lt; <span class="string">L"push_back to v["</span> &lt;&lt; i &lt;&lt; <span class="string">"]: "</span> &lt;&lt; p-&gt;Num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for_each(v.begin(), v.end(), [](<span class="built_in">shared_ptr</span>&lt;Controller&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        wcout &lt;&lt; <span class="string">L"use_count = "</span> &lt;&lt; p.use_count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        p-&gt;CheckStatuses();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RunTest();</span><br><span class="line">    wcout &lt;&lt; <span class="string">L"Press any key"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>.getline(&amp;ch, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OUTPUT</p><blockquote><p>Creating Controller0<br>Creating Controller1<br>Creating Controller2<br>Creating Controller3<br>Creating Controller4<br>push_back to v[0]: 1<br>push_back to v[0]: 2<br>push_back to v[0]: 3<br>push_back to v[0]: 4<br>push_back to v[1]: 0<br>push_back to v[1]: 2<br>push_back to v[1]: 3<br>push_back to v[1]: 4<br>push_back to v[2]: 0<br>push_back to v[2]: 1<br>push_back to v[2]: 3<br>push_back to v[2]: 4<br>push_back to v[3]: 0<br>push_back to v[3]: 1<br>push_back to v[3]: 2<br>push_back to v[3]: 4<br>push_back to v[4]: 0<br>push_back to v[4]: 1<br>push_back to v[4]: 2<br>push_back to v[4]: 3<br>use_count = 1<br>Status of 1 = On<br>Status of 2 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 2 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 3 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 2 = On<br>Status of 4 = On<br>use_count = 1<br>Status of 0 = On<br>Status of 1 = On<br>Status of 2 = On<br>Status of 3 = On<br>Destroying Controller4<br>Destroying Controller3<br>Destroying Controller2<br>Destroying Controller1<br>Destroying Controller0<br>Press any key</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> CPP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> CPP </tag>
            
            <tag> Smart Pointers </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
